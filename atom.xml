<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reku</title>
  
  
  <link href="https://reku1997.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://reku1997.gitee.io/"/>
  <updated>2021-12-16T12:53:30.580Z</updated>
  <id>https://reku1997.gitee.io/</id>
  
  <author>
    <name>Reku</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT-6.S081 2020</title>
    <link href="https://reku1997.gitee.io/2020/10/13/mit-os/"/>
    <id>https://reku1997.gitee.io/2020/10/13/mit-os/</id>
    <published>2020-10-13T07:17:57.000Z</published>
    <updated>2021-12-16T12:53:30.580Z</updated>
    
    <content type="html"><![CDATA[<p>在几个月前，试图开了一下MIT 6.828的坑，但是因为各种原因，只做了lab1就搁置了。前几天突然在知乎上看到了<a href="https://zhuanlan.zhihu.com/p/251366985">二十八画生征友：一起来通关6.S081/6.828吧~</a>，发现这个MIT 6.S081是MIT 6.828的简化版，而且梯度更加的平滑。 <span id="more"></span> 之前的一段时间都因为各种事情，忙的飞起。最近正好有一段空闲时间，希望可以在一个月内通关MIT 6.S081。</p><p>首先按照<a href="https://pdos.csail.mit.edu/6.828/2020/tools.html">tools</a>配环境，因为我用的是Ubuntu 18的虚拟机，所以需要自己手动去编译riscv-gnu-toolchain，编译的过程其实非常简单，但是下载的过程非常痛苦。这边有个<a href="https://blog.csdn.net/zhayujie5200/article/details/106374189/">老哥</a>直接把riscv-gnu-toolchain放到百度云盘上了，这样下载就会快很多而且不容易中断。</p><h1 id="lab-1-utilities">Lab-1 Utilities</h1><p>Lab1其实就是实现一些shell指令，做实验前一定要把<a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>的第一章通读一遍，<strong>非常关键！！！</strong></p><h2 id="sleep-pingpong">sleep &amp; pingpong</h2><p>相对简单，略过。这个pingpong我是用两个pipe从两个方向传输的。</p><h2 id="primes">primes</h2><p>一个非常风骚的多进程筛法。主要流程如下图：</p><p><img src="/2020/10/13/mit-os/1.PNG"></p><p>其实就是每个素数开一个进程，多个进程形成一个pipeline。按顺序输入数字，如果一个数被前面所有进程漏掉，那他显然是一个素数，就再开一个进程进入pipeline。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">36</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_fork</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> from)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prime, now;</span><br><span class="line">        now = <span class="number">-1</span>; prime = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (last != <span class="number">-1</span>) &#123;</span><br><span class="line">            close(p[last][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[from][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (read(p[from][<span class="number">0</span>], &amp;now, <span class="number">4</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime == <span class="number">-1</span>) &#123;</span><br><span class="line">                prime = now;</span><br><span class="line">                pipe(p[prime]);</span><br><span class="line">                prime_fork(from, prime);</span><br><span class="line">                close(p[prime][<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (now % prime == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(p[prime][<span class="number">1</span>], &amp;now, <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prime != <span class="number">-1</span>) &#123;</span><br><span class="line">            close(p[prime][<span class="number">1</span>]);</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipe(p[<span class="number">1</span>]);</span><br><span class="line">    prime_fork(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    close(p[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">        write(p[<span class="number">1</span>][<span class="number">1</span>], &amp;i, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我直接暴力的用了一个p数组，代表每个进程向下传输所需要的pipe。一个素数的进程的pipe就直接使用p[素数]的数组就好了。因为fd空间不够35以内的素数开满，所以要管理fd，这个地方要小心处理，我因为close了一些回收过的fd错了好几次。</p><p>一个值得注意的地方是read前的close(p[from][1])，这个bug我也卡了一小会儿，这里直接引用xv6 book中的原文：</p><blockquote><p>If no data is available, a read on a pipe waits for either data to be written or for all file descriptors referring to the write end to be closed.</p></blockquote><p>没错，是all file descriptors都要close才行，不然read就会一直挂在那里，导致死循环。</p><h2 id="find">find</h2><p>这个本身其实挺复杂的，幸好ls指令已经写好了，所以直接抄就完事儿了。</p><h2 id="xargs">xargs</h2><p>这个理论上其实很简单，就是解析标准读入进来的字符串，先按照'' split一下，再按照' ' split一下，最后拼成argv就好了。但是有个地方非常坑爹，我最开始的时候，从标准读入读字符串，简单写成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf_size = read(0, buf, (sizeof buf))</span><br><span class="line">do something with buf...</span><br></pre></td></tr></table></figure><p>这么写完之后，make grade大概五次会错一次，非常诡异。一般来说这种情况都是多进程出了问题，这时再掏出xv6 book的原文：</p><blockquote><p>The child process creates a pipe to connect the left end of the pipeline with the right end. Then it calls fork and runcmd for the left end of the pipeline and fork and runcmd for the right end, and waits for both to finish.</p></blockquote><p>一个pipe的左右指令是多进程，所以当左边指令输出，右边指令输入的时候，应该写成阻塞式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((buf_size = read(<span class="number">0</span>, buf + offset, (<span class="keyword">sizeof</span> buf) - offset)) != <span class="number">0</span>) &#123;</span><br><span class="line">    offset += buf_size;</span><br><span class="line">&#125;</span><br><span class="line">buf_size = offset;</span><br></pre></td></tr></table></figure><p>我跑了十次，全都通过了testcase。</p><h1 id="lab-2-system-calls">Lab-2 System calls</h1><p>这次实验是实现两个系统调用trace和sysinfo，感觉在实现上没什么好说的，两个任务都比较简单。这里想重点总结一下整个xv6的boot和system call的流程。</p><p>首先讲讲boot的整个流程。我们的整个实验环境是搭建在RISC-V上面的，在RISC-V中，CPU运行的指令分成三种模式：machine mode, supervisor mode和user mode。最开始的时候，CPU是处于machine mode的。开机后，CPU运行boot loader中的指令，把整个kernel都给load进来。然后进入entry.S：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_entry:</span><br><span class="line"># set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line"># jump to start() in start.c</span><br><span class="line">        call start</span><br></pre></td></tr></table></figure><p>entry.S的任务就是初始化stack，然后开始call start.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="keyword">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在RISC-V中，mret、sret和uret分别用于从machine、supervisor和user模式中的trap返回。这里调用的是mret，其实就是从machine mode返回到supervisor mode。</p><p>在main.c中，userinit函数首先allocproc()出来第一个用户进程，然后执行initcode.S中的指令，这个指令其实就是调用SYS_exec执行init.c：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure><p>在init.c中，系统生成一个名为"console"的device，并重载标准输出跟标准错误输出到这个device上，之后启动sh.c，shell启动，正式进入操作系统。</p><p>然后再讲讲整个system call的流程。这里我们可以用作业中的Sysinfo作为例子。</p><p>Sysinfo的功能是统计一下当前系统的剩余内存和已经使用的进程数量，并把这两个参数组装成一个结构体，传回给用户。这里就要分为三步，首先在user mode进行system call，进入supervisor mode，然后统计两个信息，最后system call return需要的信息回来。</p><p>我们要在user mode中调用这个sysinfo函数，但是因为这是一个系统调用，肯定不能在user mode里面实现，所以需要一个user mode的函数与supervisor mode的system call的绑定。具体到代码中，其实就是user/usys.pl中会有个entry("sysinfo")，这个语句会生成一段汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysinfo:</span><br><span class="line"> li a7, SYS_sysinfo</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p>这个ecall指令会让我们进入supervisor mode并运行SYS_sysinfo函数。那么问题来了，我们看到系统调用的参数都是(void)的，并且我们当前user mode的各种寄存器要怎么保存呢？要解决这个问题，首先要知道ecall指令到底干了什么，在xv6 book中，是这样说的：</p><blockquote><p>The ecall instruction traps into the kernel and executes uservec, usertrap, and then syscall, as we saw above.</p></blockquote><p>uservec是一段汇编，主要是保护当前的user mode现场，将user进程中的寄存器数据放到TRAPFRAME中，同时加载kernel的页表。然后调用trap.c/usertrap()。</p><p>在trap.c/usertrap()会进入syscall(void)函数，syscall(void)会根据a7寄存器中的值调用对应的system call，system call参数的传递通过TRAPFRAME中的a0-a5寄存器，运行过后的返回值放到p-&gt;trapframe-&gt;a0寄存器中。</p><p>然后调用userret，也是一段汇编代码。userret会恢复user mode的页表，并且从TRAPFRAME中恢复过去的寄存器，这样就完成了一次系统调用。但是我们发现，system call并没有传递任何值给user mode，其实system call的返回值要通过copyout函数，直接写入该进程在user mode能使用的地址中。</p><h1 id="lab-3-page-tables">Lab-3 Page tables</h1><p>这个实验相对复杂，要比较清晰的理解页表才能顺利的完成。</p><p>首先，我们要了解页表是个什么东西。其实页表就是个(key, value)的pair集合，key是虚拟地址，value是物理地址，在程序使用的地址跟计算机实际运行的内存地址之间产生一层隔离关系。</p><p>这种隔离关系的好处是，不同进程之间无法直接访问对方的变量，恶意程序也无法破坏整个操作系统，只能破坏自己的进程。</p><p>其次，还可以使得物理上不连续的、不从0开始的物理地址变成连续的、从0开始的虚拟地址，方便内核做统一的内存管理，而不是每个进程自己乱管理。</p><h2 id="print-a-page-table">Print a page table</h2><p><img src="/2020/10/13/mit-os/2-1.PNG"></p><p>完成打印页表的任务，只需要理解这个三级页表的架构就好了。从图片可以轻松了解这个数据结构，但是作为一个kv系统，为什么要这么设计呢？</p><p>其实很简单，如果页表只有一级，那就是空间换时间，一个巨大的桶存着页表。如果页表级数特别多，那访问时间就会很慢。三级页表就是个设计上的trade-off，而且这么设计，每一级页表就是一个page的大小，我觉得代码会更加规整。</p><p>判断一个页表的内容是否合法，其实就是对应一些掩码的位置，核心逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_vmprint(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> level)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; level; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> != level) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">        <span class="keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">            _vmprint((<span class="keyword">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="a-kernel-page-table-per-process">A kernel page table per process</h2><p>这个环节又涉及到一个新的问题：用户级页表和内核级页表。</p><p>在上个环节我们已经知道，页表的主要功能是为了控制访问权限。那么理论上来说，每个用户级进程都要有自己的页表，从而只能访问自己的地址，不能访问别人的地址。内核既然是随便访问，那么用一个固定不变的内核页表就好了。所以在用户级进程与系统调用之间涉及到一个页表切换的问题。</p><p>kernel page table per process要求我们实现一个新功能，内核页表不再是全局的，而是每个进程独立的。这个任务分成两步：建立每个进程自己的内核页表、实现页表切换。</p><p>首先看一下内核页表在哪里进行了改动，我只发现了两个地方，一个是kvminit()，将低地址的IO device和trampoline映射到页表中。第二个是procinit()，这里声明了进程池中每个进程的栈空间，并跟内核页表进行绑定，方便内核从每个进程的栈中获取参数之类的。</p><p>那这个建立每个进程自己的内核页表就很简单的，先把kvminit()里面的东西都映射到每个进程的内核页表中，再绑定自己进程的栈就可以了。</p><p>实现页表切换分为两步，将页表写入satp寄存器，然后用sfence.vma刷新TLB，所以页表命中是完全靠硬件，页表缺失会引起中断，需要操作系统跟硬件的配合。在scheduler()中就可以进行页表的切换，需要注意的是，进程的内核部分运行结束后要立刻把页表切换成全局的内核页表。</p><h2 id="simplify-copyincopyinstr">Simplify copyin/copyinstr</h2><p>经过上一轮的准备之后，我们可以简化copyin/copyinstr的流程。copyin是一个系统调用，要把进程中内存的一些东西copy到内核中，这里的问题在于，系统调用传入的地址是一个虚拟地址，在没有进程中的用户页表的情况下，我们无从得知该虚拟地址对应的物理地址的位置。所以在xv6中，copyin的函数签名为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyin</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">char</span> *dst, uint64 srcva, uint64 len)</span></span></span><br></pre></td></tr></table></figure><p>这里问题的关键是，因为内核页表是全局的，我们无法修改内核页表，让硬件帮助我们完成虚拟地址到物理地址的转换，所以要先进行一步软件层面的转换，然后通过内核页表的直接映射的性质去完成系统调用。当然，我们在上一个环节实现了每个进程自己维护的内核页表，所以我们可以将虚拟地址的映射加入到自己维护的内核页表中。</p><p>这里为了保持一致性，要小心的修改，在fork(), exec()和sbrk()的函数中，都有对虚拟地址映射的修改，主要增加或是改变对应内存大小。</p><p>这里其实有个问题，就是内核页表是采用直接映射的方式。也就是在映射用户的虚拟地址之前，低位其实已经映射一些内容了，这就会导致remap。一方面要调整我们的函数去忽略remap，另一方面lab指导中告诉我们，PLIC寄存器之前的空间都可以随便映射。</p><h1 id="lab-4-traps">Lab-4 Traps</h1><p>该实验系统的总结了trap的流程，其中大致的流程我们在上一篇文章lab2中都已经叙述过了，通过lab4，我们会对整个流程理解的更加深刻。</p><p>trap来自三种情况：syscall对ecall的调用、程序运行的错误、设备中断（比如时钟）。当中断发生时，我们会自动运行一段运行好的程序，当然，kernel中断跟user中断运行的程序应该是不同的，所以要用一个寄存器储存这段程序的位置。user中断的过程会相对复杂，因为user process会发生各种事情，所以我们就从user中断讲起。user中断运行的位置就是trampoline中的uservec。</p><p>uservec的功能我们lab2中已经分析过了，主要是切换页表跟保护现场两个功能。因为要使得切换页表后，trampoline中的程序在用户态和内核态都能运行，所以trampoline在内核页表和用户页表中要完全相同。</p><p>之后在usertrap中判断trap的类型，systemcall就去准备systemcall，时钟中断就去修改process的状态，错误就直接kill整个process，之后再调用userret将之前保护的现场还原回去以及将页表改回用户页表。</p><p>内核的trap跟用户的trap原理相似，但是一个很重要也很繁琐的细节就是，当user trap进入内核态的时候，内核也有可能继续trap。这就要求我们在进入user trap的时候，要准备好所有kernel trap可能用到的东西，以及保存kernel trap可能破坏的位置，方便kernel trap结束后进行恢复。</p><h2 id="risc-v-assembly">RISC-V assembly</h2><p>作业让我们熟悉一下RISC-V，群里大佬们推荐了一本包云岗翻译的RISC-V的教材，可以用来查询。</p><p>询问了一些简单的RISC-V的问题，但是要注意，他的编译器是默认开优化的，比如第一问：</p><blockquote><p>Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line"><span class="number">24</span>:<span class="number">4635</span>                lia2,<span class="number">13</span></span><br><span class="line"><span class="number">26</span>:<span class="number">45b</span>1                lia1,<span class="number">12</span></span><br><span class="line"><span class="number">28</span>:<span class="number">00000517</span>          auipca0,<span class="number">0x0</span></span><br><span class="line"><span class="number">2</span>c:<span class="number">7b</span>050513          addia0,a0,<span class="number">1968</span> # <span class="number">7</span>d8 &lt;<span class="built_in">malloc</span></span><br></pre></td></tr></table></figure><p>看指令，这个13可以理解是什么，但是这个12是哪来的。再一看f跟g函数，估计是太简单被直接常量折叠了，那我们就把编译选项加上-O0再来一遍。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line"><span class="number">4</span>c:<span class="number">4521</span>                lia0,<span class="number">8</span></span><br><span class="line"><span class="number">4</span>e:<span class="number">00000097</span>          auipcra,<span class="number">0x0</span></span><br><span class="line"><span class="number">52</span>:fce080e7          jalr<span class="number">-50</span>(ra) # <span class="number">1</span>c &lt;f&gt;</span><br><span class="line"><span class="number">56</span>:<span class="number">87</span>aa                mva5,a0</span><br><span class="line"><span class="number">58</span>:<span class="number">2785</span>                addiwa5,a5,<span class="number">1</span></span><br><span class="line"><span class="number">5</span>a:<span class="number">2781</span>                sext.wa5,a5</span><br><span class="line"><span class="number">5</span>c:<span class="number">4635</span>                lia2,<span class="number">13</span></span><br><span class="line"><span class="number">5</span>e:<span class="number">85b</span>e                mva1,a5</span><br><span class="line"><span class="number">60</span>:<span class="number">00001517</span>          auipca0,<span class="number">0x1</span></span><br><span class="line"><span class="number">64</span>:d0850513          addia0,a0,<span class="number">-760</span> # d68 &lt;<span class="built_in">malloc</span>+<span class="number">0x13e</span>&gt;</span><br><span class="line"><span class="number">68</span>:<span class="number">00001097</span>          auipcra,<span class="number">0x1</span></span><br><span class="line"><span class="number">6</span>c:<span class="number">9</span>d0080e7          jalr<span class="number">-1584</span>(ra) # a38 &lt;<span class="built_in">printf</span>&gt;</span><br></pre></td></tr></table></figure><p>可以比较清楚的看出来，第一个f(8)+1在a1寄存器中，第二个13在a2寄存器中。</p><h2 id="backtrace">Backtrace</h2><p>这个任务就是输出调用栈信息，这些任务都存在stack中，stack结构在slide中可以看到：</p><p><img src="/2020/10/13/mit-os/3-1.PNG"></p><p>其中初始的frame-pointer值，实验指导已经给出了代码。那问题就在于什么时候停止往前回溯。其实只要frame-pointer等于PGROUNDUP(fp)就可以跳出循环了。因为最浅层的那个调用既没有frame-pointer，也没有return address。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">backtrace</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  uint64 upper_bound = PGROUNDUP(fp);</span><br><span class="line">  uint64 ra;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ra = *((uint64*)(fp - <span class="number">8</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ra);</span><br><span class="line">    fp = *((uint64*)(fp - <span class="number">16</span>));</span><br><span class="line">    <span class="keyword">if</span> (fp == upper_bound) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alarm">Alarm</h2><p>这个实验难度较大，让我们实现一个syscall，可以监控cpu在该进程上的运行时间。单独监控运行时间其实比较简单，大致思路就是在process里面加个变量，当产生时间片中断时，就把这个变量++，然后输出。但问题是，实验让我们完成的函数是sigalarm(int ticks, void (*handler)())这种形式的。每次经过ticks时间片，就调用一下handler函数。</p><p>我们根据实验材料中的提示，可以简单得到这样一个思路：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;timer ++;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;timer == p-&gt;ticks) &#123;</span><br><span class="line">    p-&gt;timer = <span class="number">0</span>;</span><br><span class="line">    p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class="line">&#125;</span><br><span class="line">yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当调用usertrapret()之后，会自动运行handler位置的程序。但是当我们运行test程序之后，发现第一次监控输出之后，后面的程序会发生混乱。</p><p>简单分析一下，可以发现，我们回到handler之后，并没有再回到原本process运行的位置。这样就会产生补救的思路，先把trapframe存起来，然后当handler运行结束后，通过另一个系统调用，将trapframe恢复：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;timer ++;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;timer == p-&gt;ticks) &#123;</span><br><span class="line">    p-&gt;timer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ishandle == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;ishandle = <span class="number">1</span>;</span><br><span class="line">        memmove(p-&gt;dump_trapframe, p-&gt;trapframe, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sigreturn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;ishandle = <span class="number">0</span>;</span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;dump_trapframe, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有个slow_handler()测试点，暗示我们handler运行的过程中，计时功能应该关闭，所以我们要加一个p-&gt;ishandle变量来把门。</p><h1 id="lab-5-lazy-page-allocation">Lab-5 Lazy Page Allocation</h1><p>该实验主要是对sbrk的修改，就是当一个process要求操作系统分配更多内存给他的时候，并不直接进行分配，而是当process真的访问到该内存的时候，再进行分配，整个过程都是由缺页中断进行驱动的。</p><h2 id="eliminate-allocation-from-sbrk">Eliminate allocation from sbrk()</h2><p>非常简单，只要修改p-&gt;sz就行了，不需要进行任何其他操作。</p><h2 id="lazy-allocation">Lazy allocation</h2><p>通过这个case其实也非常简单，我感觉怎么写都能过，我在写这个的时候错了好几个地方，都成功通过echo hi了。</p><p>原理也比较简单，就是在缺页中断的时候调用一下mappages。</p><h2 id="lazytests-and-usertests">Lazytests and Usertests</h2><p>这个任务要求我们通过修改上一个任务的代码，从而通过两个非常复杂的程序。这里我遇到了两个非常坑爹的地方。</p><p>首先是lazytests里面的oom，我总是在oom之前就发生p-&gt;sz整数溢出。发现p-&gt;sz是uint64类型的，理论不应该溢出才是。</p><p>观察一下原有的sbrk的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> addr;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">addr = myproc()-&gt;sz;</span><br><span class="line"><span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br></pre></td></tr></table></figure><p>这里，大部分人第一次都会去用myproc()-&gt;sz=addr+n来修改sbrk，然而这个位置会导致整形溢出，也就是他默认的数据类型会溢出，非常坑爹！</p><p>还有一个地方，更加恶心。就是usertests的sbrkargs，我跑了所有其他case都能通过，就这个case无法通过。</p><p>经过细致的排查，发现sbrkarg的特殊之处在于，他是在copyin这个函数里面软查找页表的时候产生缺页的，不会产生缺页中断，但是会导致写入失败。所以要在walkaddr里面也处理一下lazy alloc的情况。</p><p>也就是说，不是所有缺页都是通过缺页中断驱动的，真是令人作呕的设计啊...</p><h1 id="lab-6-copy-on-write-fork-for-xv6">Lab-6 Copy-on-Write Fork for xv6</h1><p>下面是页表的最后一个实验，实现xv6 fork的COW机制。</p><p>超级恶心，写了我整整一天，各种坑点非常多，而且难以debug。这里建议先从给页表进行引用计数下手，一个显而易见的思路是，将kmem改成如下这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="keyword">int</span> ref_cnt[PHYSTOP / PGSIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><p>可能有人会疑惑这个引用数组到底开到了RAM的什么地方？其实这个数组会在link的时候开到RAM上，并通过linker算出extern char end[]的位置，所以只要不是太大，并不会影响到整个程序的运行。这个其实就相当于一个无碰撞的hash表，如果想节省内存，还可以搞点复杂的hash表动态扩容啥的，然而嫌麻烦，就没有搞。然后这个freelist记录的就是所有引用计数为0的page了。</p><p>后面就需要注意uvmcopy以及缺页中断的情况了。在实验的提示中，他说可以利用RISC-V的RSW位，然而我并没有用这个东西，最后也成功通过了所有的case，核心函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">fix_cow</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="keyword">if</span> ((pa = walkaddr(pagetable, va)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  <span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  memmove(mem, (<span class="keyword">char</span>*)pa, PGSIZE);</span><br><span class="line">  uvmunmap(pagetable, va, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我最开始的时候把前两个if写反了，导致countfree怎么都通过不了，非常坚硬，研究了半天。要小心谨慎的维护page，基本所有错误都是page的alloc和free导致的。</p><h1 id="lab-7-multithreading">Lab-7 Multithreading</h1><p>教材这一部分有点难读，大量内容都在解释有关xv6内部内核线程同步的代码，有些烧脑。幸好作业部分非常简单，完成的非常顺利。</p><h2 id="uthread-switching-between-threads">Uthread: switching between threads</h2><p>这个任务是给xv6添加用户线程，其实跟内核线程的添加方式几乎完全相同，因为没有让我们实现锁机制，所以整体的思路非常简单。</p><p>最核心的地方就是切换thread运行的context，这个地方采用跟内核线程一样的方式，只要保存返回地址、栈指针、callee-saved就可以了。</p><p>通过阅读xv6教材，我的理解是，其实内核没有进程的概念，只有用户有进程的概念。只是用户进程trap进入内核态之后，有个内核线程与该进程绑定而已。</p><h2 id="using-threads">Using threads</h2><p>这个任务也非常简单，给一个最简单的开散列hash表加锁，并稍微优化一下性能。</p><p>最简单的思路就是每个bucket都加个锁，恰好能达到要求的1.25x的加速：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  pthread_mutex_lock(&amp;lock[i]);       <span class="comment">// acquire lock</span></span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock[i]);     <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="barrier">Barrier</h2><p>barrier指的就是所有线程都执行到此步之后，在进行后续的程序执行。实际上是对xv6的sleep和wakeup机制的复习。</p><p>整体思路也比较简单，只要加锁就好了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">barrier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread ++;</span><br><span class="line">  <span class="keyword">if</span> (bstate.nthread != nthread) &#123;</span><br><span class="line">      pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      bstate.nthread = <span class="number">0</span>;</span><br><span class="line">      bstate.round ++;</span><br><span class="line">      pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lab-8-locks">Lab-8 Locks</h1><p>教材中主要讲解了xv6系统中各种锁的设计理念。在xv6中，内部锁是由_sync_语句来保证原子性的，感觉这种思路确实相对比较简单。</p><p>因为CPU会进行乱序发射之类的指令顺序的优化，所以在很多情况下，需要显式的加上__sync_synchronize()，防止CPU进行跨越该语句的乱序发射。</p><p>两个任务具有一定的相似性，一个是优化buffer cache的锁，一个是优化kalloc的锁。我采用的方案也比较相似，在kalloc中，每个CPU弄一个独立的链表，在buffer cache中，每个blockbnum的hash值弄一个独立的链表。</p><p>在刚刚开始进行kalloc实验的时候，我走进了一个误区，以为freerange是在每个CPU上面执行的，这里保留一下学习群里的聊天记录，感谢群里的老哥们：</p><p><img src="/2020/10/13/mit-os/5-1.PNG"></p><h1 id="lab-9-file-system">Lab-9 File System</h1><p>感觉教材阅读起来比较困难，因为整个 File System 是分成 7 层层层抽象来构建的，我边参考代码边读了差不多三四遍，才完全把整个结构理解。整个层级图如下图所示：</p><p><img src="/2020/10/13/mit-os/5-2.PNG"></p><h2 id="large-files">Large files</h2><p>这个任务的难度不是太大，正常的文件 innode 结构是这样的：</p><p><img src="/2020/10/13/mit-os/5-3.PNG"></p><p>这样的二级结构使得每个文件只能支持 12+256 个 block，可以变成三级结构，使得整个文件能达到 11+256+256*256 个 block。只要小心的修改 itrunc 和 bmap 函数就可以了。</p><h2 id="symbolic-links">Symbolic links</h2><p>这个任务的难点在于要清晰的了解他想让你实现的 Symbolic links 行为到底是什么样子的。当 open 不带有 O_NOFOLLOW 标记时，需要一直向下找到 hard link 的位置。整个 symbolic link 的内容都要放在对应的 inode 上面，实际上只需要自己去将文件路径和路径长度保存在 inode 里面就可以了。</p><p>open 的修改部分： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((omode &amp; O_NOFOLLOW) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">char</span> s[MAXPATH];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, length;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; <span class="number">10</span> &amp;&amp; ip-&gt;type == T_SYMLINK)&#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">        readi(ip, <span class="number">0</span>, (uint64)&amp;length, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        readi(ip, <span class="number">0</span>, (uint64)s, <span class="number">4</span>, length);</span><br><span class="line">        s[length] = <span class="number">0</span>;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        <span class="keyword">if</span>((ip = namei(s)) == <span class="number">0</span>)&#123;</span><br><span class="line">            end_op();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ilock(ip);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= <span class="number">10</span> &amp;&amp; ip-&gt;type == T_SYMLINK)&#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sym_link: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">len</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span>(cnt = <span class="number">0</span>; cnt &lt; MAXPATH; cnt ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[cnt] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_symlink</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    begin_op();</span><br><span class="line">    <span class="keyword">if</span>((ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = len(target);</span><br><span class="line">    writei(ip, <span class="number">0</span>, (uint64)&amp;length, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">4</span>, length + <span class="number">1</span>);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="lab-10-mmap">Lab-10 Mmap</h1><p>这个实验的难点在于，mmap 要实现成 lazy alloc 的形式，所以要对页表进行大量的操作，然而做到 lab-10 可能前面页表的细节已经完全忘干净了（</p><p>不过缺点也在于测试样例过于简单，感觉覆盖的场景非常不完全。</p><p>对于这个 lazy alloc 的处理，我选择了一种比较取巧的方式，就是在开始的时候完全按照 lazy alloc 的那个方式来写，在最后判断的时候，多加一个 mmap 的判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">mmaplazyalloc</span><span class="params">(<span class="keyword">int</span> va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">int</span> found = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mmaps[i].used) &#123;</span><br><span class="line">      uint64 start = p-&gt;mmaps[i].addr;</span><br><span class="line">      uint64 end = p-&gt;mmaps[i].addr + p-&gt;mmaps[i].length;</span><br><span class="line">      <span class="keyword">if</span> (va &gt;= start &amp;&amp; va &lt; end) &#123;</span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;mmaps[i].f;</span><br><span class="line">  <span class="keyword">int</span> offset = p-&gt;mmaps[i].offset;</span><br><span class="line">  uint64 off = offset + va - p-&gt;mmaps[i].addr;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  ilock(f-&gt;ip);</span><br><span class="line">  <span class="keyword">if</span> (readi(f-&gt;ip, <span class="number">1</span>, va, off, PGSIZE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    panic(<span class="string">&quot;lazyalloc read.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(f-&gt;ip);</span><br><span class="line">  end_op();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    va = PGROUNDDOWN(va);</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= p-&gt;sz || va &lt; PGROUNDUP(p-&gt;trapframe-&gt;sp)) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (walkaddr(p-&gt;pagetable, va) == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mmaplazyalloc(va);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另一个比较麻烦的地方就是对 munmap 的处理，因为题目保证了 munmap 要么截断前面，要么截断后面，不会截断中间，所以要对这几种情况进行调整：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_mmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> length, prot, flags, fd, offset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> ||</span><br><span class="line">    argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span> ||</span><br><span class="line">    argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> ||</span><br><span class="line">    argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> ||</span><br><span class="line">    argfd(<span class="number">4</span>, &amp;fd, &amp;f)  &lt; <span class="number">0</span> ||</span><br><span class="line">    argint(<span class="number">5</span>, &amp;offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((prot &amp; PROT_WRITE) &amp;&amp; !f-&gt;writable &amp;&amp; flags == MAP_SHARED)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1UL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;mmaps[i].used) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">v</span> =</span> &amp;p-&gt;mmaps[i];</span><br><span class="line">      v-&gt;addr = p-&gt;sz;</span><br><span class="line">      v-&gt;length = length;</span><br><span class="line">      v-&gt;f = f;</span><br><span class="line">      v-&gt;prot = prot;</span><br><span class="line">      v-&gt;used = <span class="number">1</span>;</span><br><span class="line">      v-&gt;flags = flags;</span><br><span class="line">      v-&gt;offset = offset;</span><br><span class="line">      p-&gt;sz = p-&gt;sz + length;</span><br><span class="line">      filedup(f);</span><br><span class="line">      <span class="keyword">return</span> v-&gt;addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_munmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="keyword">int</span> found = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> ||</span><br><span class="line">    argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">v</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mmaps[i].used) &#123;</span><br><span class="line">      uint64 start = p-&gt;mmaps[i].addr;</span><br><span class="line">      uint64 end = p-&gt;mmaps[i].addr + p-&gt;mmaps[i].length;</span><br><span class="line">      <span class="keyword">if</span> (addr &gt;= start &amp;&amp; addr &lt; end) &#123;</span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">        v = &amp;p-&gt;mmaps[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; length; offset += PGSIZE) &#123;</span><br><span class="line">    uint64 a = addr + offset;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mmaps[i].flags &amp; MAP_SHARED) &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *pte = walk(p-&gt;pagetable, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>) &#123;</span><br><span class="line">            begin_op();</span><br><span class="line">            ilock(v-&gt;f-&gt;ip);</span><br><span class="line">            writei(v-&gt;f-&gt;ip, <span class="number">1</span>, a, a - v-&gt;addr + v-&gt;offset, PGSIZE);</span><br><span class="line">            iunlock(v-&gt;f-&gt;ip);</span><br><span class="line">            end_op();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    uvmunmap(p-&gt;pagetable, a, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (addr == v-&gt;addr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == v-&gt;length) &#123;</span><br><span class="line">      v-&gt;used = <span class="number">0</span>;</span><br><span class="line">      fileclose(v-&gt;f);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addr + length &gt; v-&gt;addr + v-&gt;length) &#123;</span><br><span class="line">      panic(<span class="string">&quot;munmap: wrong&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      v-&gt;addr = addr + length;</span><br><span class="line">      v-&gt;offset = v-&gt;offset + length;</span><br><span class="line">      v-&gt;length -= length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (addr + length == v-&gt;addr + v-&gt;length) &#123;</span><br><span class="line">      v-&gt;length = addr - v-&gt;addr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      panic(<span class="string">&quot;munmap: wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，我们在 writei 的时候，截断的 offset 要补入 p-&gt;mmaps[i] 的 offset 中，这样才能找到正确的 offset。</p><h1 id="lab-11-networking">Lab-11 Networking</h1><p>最后一个实验了，非常简单，就是让我们实现 e1000_transmit 和 e1000_recv 这两个函数。看起来仿佛非常复杂，实际上按照 hint 模拟就好了。</p><p>但是有个地方需要注意，在 hint 中， e1000_recv 实现方式如下：</p><blockquote><p>Some hints for implementing e1000_recv: First ask the E1000 for the ring index at which the next waiting received packet (if any) is located, by fetching the E1000_RDT control register and adding one modulo RX_RING_SIZE. Then check if a new packet is available by checking for the E1000_RXD_STAT_DD bit in the status portion of the descriptor. If not, stop. Otherwise, update the mbuf's m-&gt;len to the length reported in the descriptor. Deliver the mbuf to the network stack using net_rx(). Then allocate a new mbuf using mbufalloc() to replace the one just given to net_rx(). Program its data pointer (m-&gt;head) into the descriptor. Clear the descriptor's status bits to zero. Finally, update the E1000_RDT register to be the index of the last ring descriptor processed. e1000_init() initializes the RX ring with mbufs, and you'll want to look at how it does that and perhaps borrow code. At some point the total number of packets that have ever arrived will exceed the ring size (16); make sure your code can handle that.</p></blockquote><p>但是在实际实现中，net_rx要先release锁之后才能去运行，不然就会panic：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">e1000_recv</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    acquire(&amp;e1000_lock);</span><br><span class="line">    uint32 idx = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">desc</span> =</span> &amp;rx_ring[idx];</span><br><span class="line">    <span class="keyword">if</span> (!(desc-&gt;status &amp; E1000_RXD_STAT_DD)) &#123;</span><br><span class="line">        release(&amp;e1000_lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rx_mbufs[idx]-&gt;len = desc-&gt;length;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span> =</span> rx_mbufs[idx];</span><br><span class="line">    rx_mbufs[idx] = mbufalloc(<span class="number">0</span>);</span><br><span class="line">    desc-&gt;addr = (uint64) rx_mbufs[idx]-&gt;head;</span><br><span class="line">    desc-&gt;status = <span class="number">0</span>;</span><br><span class="line">    regs[E1000_RDT] = idx;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    net_rx(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在几个月前，试图开了一下MIT 6.828的坑，但是因为各种原因，只做了lab1就搁置了。前几天突然在知乎上看到了&lt;a href=&quot;https://zhuanlan.zhihu.com/p/251366985&quot;&gt;二十八画生征友：一起来通关6.S081/6.828吧~&lt;/a&gt;，发现这个MIT 6.S081是MIT 6.828的简化版，而且梯度更加的平滑。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://reku1997.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="https://reku1997.gitee.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>GNN for Source Code Modeling（三）</title>
    <link href="https://reku1997.gitee.io/2020/03/09/gnn-for-source-code-modeling-3/"/>
    <id>https://reku1997.gitee.io/2020/03/09/gnn-for-source-code-modeling-3/</id>
    <published>2020-03-09T12:51:24.000Z</published>
    <updated>2021-12-16T11:28:06.554Z</updated>
    
    <content type="html"><![CDATA[<p>实际上 GNN 在 Source Code 上的应用和创新还有很多。之前的两篇文章都是关于 GNN 建图以及 GNN 跟其他任务相结合的工作，这篇文章就讲一下对 GNN 本身的创新。</p><span id="more"></span><p><a href="https://arxiv.org/abs/1904.12787">Graph Matching Networks for Learning the Similarity of Graph Structured Objects. ICML 2019</a> 就是一个利用 GNN 解决二进制函数相似性问题的工作。这个问题也是 Source Code Modeling 领域的经典问题之一。 二进制函数相似性是一个在信息安全领域应用很广泛的问题。因为很多软件都是不开源的，放在用户电脑上的只能是一些二进制代码。因为编译器、编译选项以及平台的不同，同一个函数的二进制代码也经常是不同的。如果一个函数被检查出了安全漏洞，那这个函数所编译出的所有二进制代码也会有安全漏洞。这些二进制代码放在成千上万用户的电脑上，造成非常大的安全隐患，所以及时找到这些代码是非常重要的。因为二进制代码本身会有一个 Control-flow-graph，所以利用 GNN 解决二进制函数相似性就成为 GNN 的一个应用。</p><p><img src="/2020/03/09/gnn-for-source-code-modeling-3/1-1.png"></p><p>论文中给出两种方式来解决这个问题。第一种是输入一个图输出一个 embedding，通过优化这个 embedding 使得两个相似的图的 embedding 会离得更近。第二种更加直接，输入两个图，输出他们的相似性。这两种方式都是在 GNN 的基础上做的。</p><p><img src="/2020/03/09/gnn-for-source-code-modeling-3/2-1.png"></p><p>第一种方法计算 embedding 的过程没啥好说的，就是输入<span class="math inline">\((G_1, G_2)\)</span>输出<span class="math inline">\((h_{G_1},h_{G_2})\)</span>。重点在于最后的 loss 设计，因为跟第二种可以共用相同的 loss，所以放到一起最后讲。 对于第二种方法，大多数步骤跟 GNN 都是一样的。主要区别在于在聚合邻居信息的时候，也要聚合另一张图的信息 <span class="math inline">\(\mu\)</span>：</p><p><img src="/2020/03/09/gnn-for-source-code-modeling-3/3-1.png"></p><p>其中<span class="math inline">\(\mu\)</span>的计算方式如下，上面的<span class="math inline">\(f_s\)</span>和下面的<span class="math inline">\(s_h\)</span>都是可以替换的向量相似度计算方式：</p><p><img src="/2020/03/09/gnn-for-source-code-modeling-3/4-1.png"></p><p>观察公式<span class="math inline">\((11)\)</span>可以发现，attention 值越大，两个点越相似。所以这个<span class="math inline">\(\Sigma\mu\)</span>其实就是该点的 embedding 跟另一张图最相似的点的 embedding 的差。如果两个图完全一样，那这个<span class="math inline">\(\Sigma\mu\)</span>就会一直是<span class="math inline">\(0\)</span>。所以这个 GMN 的优势就是通过一个图的表示可以更改另一个图的表示，从而捕捉两个图的不相似程度。 下面是两种方法的 loss。论文定义了两种 label，第一种是<span class="math inline">\((G_1,G_2,t)\)</span>，两个图相似<span class="math inline">\(t=1\)</span>，不相似<span class="math inline">\(t=-1\)</span>。第二种是<span class="math inline">\((G_1,G_2,G_3)\)</span>，其中<span class="math inline">\(G_1\)</span>跟<span class="math inline">\(G_2\)</span>更加相似。如果向量相似性用欧拉距离来度量，那可以用一种类似合页 loss 的方式来进行优化：</p><p><img src="/2020/03/09/gnn-for-source-code-modeling-3/5-1.png"></p><p><img src="/2020/03/09/gnn-for-source-code-modeling-3/6-1.png"></p><p>公式<span class="math inline">\((12)\)</span>可以看做当两个图相似的时候，距离应该小于<span class="math inline">\(1-\gamma\)</span>，当两个图不相似的时候，距离应该大于<span class="math inline">\(1+\gamma\)</span>。 公式<span class="math inline">\((13)\)</span>可以看做<span class="math inline">\(d(G_1,G_2)\lt d(G_1,G_3)-\gamma\)</span>。</p><p><img src="/2020/03/09/gnn-for-source-code-modeling-3/7-1.png"> 也可以按照上面的公式，用 Hamming 相似度来算，这样的好处是向量里面每一维度都是<span class="math inline">\([1,-1]\)</span>，容易在大型数据库中快速的查询。</p><p><img src="/2020/03/09/gnn-for-source-code-modeling-3/8-1.png"></p><p>可以看到，效果有一定的提升。这里的 baseline 是 Google 的一个二进制代码查询工具，利用手工构造的图 hash 来寻找相同的代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实际上 GNN 在 Source Code 上的应用和创新还有很多。之前的两篇文章都是关于 GNN 建图以及 GNN 跟其他任务相结合的工作，这篇文章就讲一下对 GNN 本身的创新。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="program" scheme="https://reku1997.gitee.io/tags/program/"/>
    
    <category term="graph" scheme="https://reku1997.gitee.io/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>GNN for Source Code Modeling（二）</title>
    <link href="https://reku1997.gitee.io/2020/03/08/gnn-for-source-code-modeling-2/"/>
    <id>https://reku1997.gitee.io/2020/03/08/gnn-for-source-code-modeling-2/</id>
    <published>2020-03-07T17:18:25.000Z</published>
    <updated>2021-12-16T11:26:15.390Z</updated>
    
    <content type="html"><![CDATA[<p>这篇讲一个基于<a href="https://reku1997.gitee.io/2020/03/07/gnn-for-source-code-modeling-1/">上一篇</a>的改进工作。 在 Source Code 中，因为程序员的变量命名通常来讲都比较诡异，所以存在着比较严重的 open vocabulary 问题（也叫作 Out of Vocabulary）。比如一个变量名叫做 LianlianInput，因为这个 Lianlian 不在词汇表里面，VARNAMING 的时候就根本不会输出这个 subtoken，对最后的效果有比较严重的影响。</p><span id="more"></span><p><a href="https://arxiv.org/abs/1810.08305">Open Vocabulary Learning on Source Code with a Graph-Structured Cache. ICML 2019</a> 这篇文章就致力于解决代码中的 open vocabulary 问题，而且是通过 GNN 来解决，与我们的主题十分契合。 整个建图过程跟之前的工作非常类似，只是多了 Graph-Structured Cache Node：</p><p><img src="/2020/03/08/gnn-for-source-code-modeling-2/5.png"></p><p>其实也是先分词，然后相同的词搞一个节点而已。初始的特征是节点名字特征跟Cache节点类型本身有个特征进行拼接。节点名字特征用 CharCNN 来计算。 建图层面还是比较简单的，这篇文章主要的贡献之处在于利用 GSC 节点来解决 open vocabulary 的问题。解决的方法在于修改 GNN 最后一步<span class="math inline">\(y=g(\{h_v^t\})\)</span>中<span class="math inline">\(g\)</span>的计算方式，灵感来自于 Pointer Network。为了方便之后理解，先简单叙述一下啥是 Pointer Network。 这个 Pointer Network 本来是做组合优化的，最开始用来解决凸包问题。凸包问题我们都知道，输入一个点集，输出一个凸包。但是这个输出的范围其实是跟输入相关的。Pointer Network 用了很简单的机制解决了这个问题：</p><p><img src="/2020/03/08/gnn-for-source-code-modeling-2/6.png"></p><p>在传统的 attention 中，都是 encoder 和 decoder 的 hidden layer 算个权重，然后组合一下 encoder 的所有权重输入到 decoder 中。这里的输出就直接把 attention 的最大权重作为其中一步的输出，并且输入到 encoder 中继续形成新的 hidden layer。 下面就看看如何利用 GSC 解决 VARMISUSE 的问题。在前一篇文章中，这个 VARMISUSE 问题解决起来其实还是比较复杂的。这篇文章用 Java 项目作为数据集。因为 Java 跟垃圾语言 Python 不一样，是一个要先声明后调用的语言。所以对单独语法槽的预测，都可以变成一个 Pointer Network 问题，指向现存的变量节点。对于 GGNN 来说，简单按照<span class="math inline">\(y=\sigma(f_1(h_v^t,h_v^0)\odot f_2(h_v^t))\)</span>来计算一下 attention 权重（其实我不太懂这个 attention 为什么跟槽的 embedding 无关，可能是因为 GGNN 论文里面的 readout attention 就是这么做的），挑其中最大的几个作为输出即可。</p><p><img src="/2020/03/08/gnn-for-source-code-modeling-2/7.png"></p><p>可以看到，加上 GSC 之后效果有一定的提升。 解决 VARNAMING 的思路跟 Pointer Sentinel Mixture Model 非常相似。Pointer Sentinel Mixture Model 就是把纯 attention 求出来的 open vocabulary 分布和正常 attention 求出来的 close vocabulary 分布加到一起，来预测要产生的序列：</p><p><img src="/2020/03/08/gnn-for-source-code-modeling-2/9.png"></p><p>这个 open vocabulary 和 close vocabulary 组合的权重利用一个名为 sentinel 的虚拟输入的 attention 值来计算。 对于 VARNAMING 来说，也是按照上一篇文章的方法建图，对于所有要命名的变量 embedding 取一个平均值，然后作为输入放到 GRU 中。close vocabulary 的分布按照正常的方式产生，Pointer Network 的 attention 权重就是把每个 GSC 或者 sentinel 的 embedding 输入到一个线性层，然后跟 hidden layer 点积一下接一个 softmax。最后的公式就是：<span class="math display">\[P(w|h)=P_{graph}(s|h)P_{graph}(w|h)+(1-P_{graph}(s|h))P_{vocab}(w|h)\]</span></p><p><img src="/2020/03/08/gnn-for-source-code-modeling-2/8.png"></p><p>可以看出，实验效果提升巨大。可能看起来还是不怎么样，但是要考虑到这个问题的难度，做成这样就不错了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇讲一个基于&lt;a href=&quot;https://reku1997.gitee.io/2020/03/07/gnn-for-source-code-modeling-1/&quot;&gt;上一篇&lt;/a&gt;的改进工作。 在 Source Code 中，因为程序员的变量命名通常来讲都比较诡异，所以存在着比较严重的 open vocabulary 问题（也叫作 Out of Vocabulary）。比如一个变量名叫做 LianlianInput，因为这个 Lianlian 不在词汇表里面，VARNAMING 的时候就根本不会输出这个 subtoken，对最后的效果有比较严重的影响。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="program" scheme="https://reku1997.gitee.io/tags/program/"/>
    
    <category term="graph" scheme="https://reku1997.gitee.io/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>GNN for Source Code Modeling（一）</title>
    <link href="https://reku1997.gitee.io/2020/03/07/gnn-for-source-code-modeling-1/"/>
    <id>https://reku1997.gitee.io/2020/03/07/gnn-for-source-code-modeling-1/</id>
    <published>2020-03-07T10:10:17.000Z</published>
    <updated>2021-12-16T11:27:58.990Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Source Code 的 learning 其实已经有很多工作了，每年的顶会中也有很多这个方面的文章。其实针对 Source Code 的 learning 可以算是 NLP 的一个子领域，因为 Source Code 本身就是就是程序员之间交流的一种语言。因为 Code 是一个结构化数据，存在着语义信息与语法信息，所以相比于自然语言来说，Source Code 是适合于 GNN 大显神威的领域。</p><span id="more"></span><p><a href="https://arxiv.org/abs/1711.00740">Learning to Represent Programs with Graphs. ICLR 2018</a> 是 GNN 在 Source Code 中运用的比较早的工作，质量也蛮高。 首先定义一下这篇文章要解决的两个问题： 第一个问题叫做 VARNAMING，就是在一段代码中有个匿名的变量，然后要通过这个变量在代码中的行为来对这个变量命名。 第二个问题叫做 VARMISUSE，类似于程序填空，预测一个程序中空缺的 token 是什么。通过这个任务，可以发现代码中一些 misuse 性质的 bug，举例如下：</p><p><img src="/2020/03/07/gnn-for-source-code-modeling-1/1.png"></p><p>当然，对于第二个任务来说，合法的解可能有好几个，就跟考试的程序填空中有好多正确答案一样。 根据文章的标题，可以想象文章的内容就是把 program 建成一个图，然后在图上面跑 GNN。文章中所采取的的 GNN 是 GGNN (Gated Graph Neural Networks)，可能是因为这个 GGNN 比较适合 program 建的图，所以很多后续工作采用的也是这个方法。 图定义为<span class="math inline">\(G=(V,E,X)\)</span>，其中<span class="math inline">\(V\)</span>是节点、<span class="math inline">\(X\)</span>是特征，<span class="math inline">\(E=(E_1,...,E_k)\)</span>是边的集合，边有<span class="math inline">\(k\)</span>种。 每个节点状态为<span class="math inline">\(h^{(v)}\)</span>，初始状态就是<span class="math inline">\(x^{v}\)</span>。跟传统的 GNN 一样，每个节点会向外发送<span class="math inline">\(k\)</span>的类型的消息<span class="math inline">\(m_k^{(v)}=f_k(h^{v})\)</span>，然后每个节点聚合邻居的消息<span class="math inline">\(\widetilde{m}^{(v)}=g(\{m_k^{(u)}\}\mid{(u,v,k)\in E})\)</span>。 特殊之处在于更新<span class="math inline">\(h^{(v)}\)</span>的方式，GGNN 用的是 GRU 单元来更新特征向量。<span class="math inline">\(h^{(v)}=GRU(\widetilde{m}^{(v)},h^{v})\)</span>。这样可以捕捉到一些较远的点对该点的影响。 在该论文中，<span class="math inline">\(f_k\)</span>是一个线性函数，<span class="math inline">\(g\)</span>是个简单的求和。 这篇论文中比较炫酷的部分是建图。首先一个程序，自然对应一个 AST，这个 AST 的叶子节点是程序中的 token，中间节点对应着 BNF 的中间节点。因为 GNN 捕捉不了树的儿子的顺序，所以要加一个 NextToken 边来把 token 都串起来：</p><p><img src="/2020/03/07/gnn-for-source-code-modeling-1/2.png"></p><p>另一方面，我们要捕捉程序的 Data-flow 信息。对于每个变量来说，上一次 read 的位置，连接一个 LastRead 边，因为有分支结构存在，这种边可能有多条。同样，上一次 write 的位置，连接一个 LastWrite 边。有赋值语句存在的时候，左右两边的语句要连接一个 ComputedFrom 边：</p><p><img src="/2020/03/07/gnn-for-source-code-modeling-1/3.png"></p><p>作者还加了很多乱七八糟的边，比如用 LastLexicalUse 来把所有同一个变量的调用都串起来。return 后面接的变量也会通过 ReturnTo 边连接到方法的声明上。对于形如 Foo(bar) 和 Foo(InputStream Stream) 这样的方法调用与声明，bar 也会连接到 stream 上。最后，对于 if(x&gt;y){...x...}else{...y...} 这样的语句，x 向条件节点连一个 GuardedBy 边，y 向条件节点连接一个 GuardedByNegation 的边。 最后再把所有反向边都加入，也就是形成一个无向图。这个图就处理好了。 这篇文章做实验用的是 C# 的一些项目。跟 Python 这种垃圾语言不一样，C# 每个变量是有固定的类型信息的，这种类型信息显然是可以运用的。作为一个高贵的 OOP 语言，C# 的类型还是有层级的。对于一个类型<span class="math inline">\(\tau\)</span>，有一个 embedding 函数 <span class="math inline">\(r(\tau)\)</span>。因为这个类型具有层次结构，所以可以搞一个集合<span class="math inline">\(\tau^{*}(v)\)</span>，里面具有<span class="math inline">\(v\)</span>本身的类型和<span class="math inline">\(v\)</span>所有的父类型的 embedding，然后对这个集合每一维度取个最大值，作为变量<span class="math inline">\(v\)</span>的类型特征。可以用类似 dropout 的方法来进行优化。 变量<span class="math inline">\(v\)</span>还具有变量名，可以把变量<span class="math inline">\(v\)</span>的变量名进行分词，分出来一堆 subtoken。这些 subtoken 的表示取一个平均作为变量名的特征。把变量名特征跟类型特征连接起来，得到每个节点的最初表示。 整个网络的结构有了，下面就是用这个网络来解决 VARNAMING 跟 VARMISUSE 了。 对于 VARNAMING 来说，可以把要命名的变量名替换为 SLOT token。然后跑一遍 GNN，对于每一处变量的表示取个平均值。这个值作为一个 GRU 的输入，来生成一堆 subtoken 作为变量名。这样就转变为一个 GraphToSeq 的问题。 VARMISUSE 的问题会相对复杂一点。首先也是把目标位置<span class="math inline">\(c(t)\)</span>替换为一个匿名的 SLOT 变量。正常连边的时候，变量相关的变量应该都不会连接到 SLOT 变量上。然后将候选集中的每个变量<span class="math inline">\(v_{t,v}\)</span>加入到这个图中，并连接好变量相关的边。在这个图上跑 GNN，可以得到<span class="math inline">\(h^{SLOT}\)</span>和<span class="math inline">\(h^{v_{t,v}}\)</span>。最后通过<span class="math inline">\(argmax_v W[h^{SLOT}, h^{v_{t,v}}]\)</span>来找到正确的变量。</p><p><img src="/2020/03/07/gnn-for-source-code-modeling-1/4.png"></p><p>相比一些简单的 baseline，这个方法效果提升巨大。值得注意的是，加入的各种边和节点的 embedding 也非常的 make sense，对最后的效果很有帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于 Source Code 的 learning 其实已经有很多工作了，每年的顶会中也有很多这个方面的文章。其实针对 Source Code 的 learning 可以算是 NLP 的一个子领域，因为 Source Code 本身就是就是程序员之间交流的一种语言。因为 Code 是一个结构化数据，存在着语义信息与语法信息，所以相比于自然语言来说，Source Code 是适合于 GNN 大显神威的领域。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="GNN" scheme="https://reku1997.gitee.io/tags/GNN/"/>
    
    <category term="program" scheme="https://reku1997.gitee.io/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>AutoTVM 探秘 （三）</title>
    <link href="https://reku1997.gitee.io/2020/01/02/autotvm-3/"/>
    <id>https://reku1997.gitee.io/2020/01/02/autotvm-3/</id>
    <published>2020-01-02T08:48:01.000Z</published>
    <updated>2020-07-20T08:26:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于目前的优化算法来说，依然存在着许多问题。但是后续的工作并不是特别多。首先可以看一下 <a href="https://arxiv.org/abs/1905.12799">Reinforcement Learning and Adaptive Sampling for Optimized DNN Compilation, ICML 2019 Workshop RL4RealLife</a> 这篇文章主要谈到的问题是两点：1. 开发一个更有效的搜索算法（相对于 AutoTVM 的模拟退火） 2. 减少硬件测试的时间。从这篇文章的实验结果来看，第一个目标基本上没有达成，第二个目标完成的还不错。这个第二个目标也是我认为的之后优化的核心问题。 文章的整个框架如下图，主要贡献是两个蓝色的部分——基于强化学习的搜索和自适应采样。</p><span id="more"></span><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-上午11.50.38.png"></p><p>整个过程不是很复杂，这个强化学习其实就是用来代替模拟退火的。迭代数次 Policy Network，输入是一个当前算子的 config，也就是之前说的 schedule，输出是对 config 的上下调整。强化学习要从环境里面获取代价，这个代价其实就是从 cost model 里面预测出来的每个 config 的运行时间，再用 PPO 的方式去训练 Policy Network，这个强化学习套路感觉非常的强行，最后效果也一般般。 然后对所有的 config 进行自适应采样，只对采样出来的 config 在硬件上测试实际的运行时间，然后将采样出来的 config 用于 cost model 的训练。这个所谓的自适应采样其实非常简单，就是对所有 config 做一个 k-means，然后采样每个centroid。</p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午12.01.27.png"></p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午12.01.34.png"></p><p>从上面两个图可以看出，第二步自适应采样的动机还是比较强的。因为对于 AutoTVM 来说，大量的时间都用于在硬件上测试算子的运行时间，而且相似的算子 config 确实很多，所以通过聚类然后采样的想法确实比较直接。最后的加速效果也不错：</p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午12.04.10.png"></p><p>通过结果可以看出来，虽然最后的加速效果很不错，但是对于结果的优化程度几乎没什么变化。说明第二步自适应采样很有效，但是第一步强化学习其实没什么用。讽刺的是这个进的还是 RL4RealLife Workshop... 对于 AutoTVM 来说，目前最主要的问题还是 tuning 的时间过慢。所以 AutoTVM 只能用于 inference，不能用于 training。因为你 tuning 的时间很有可能就比 training 的时间长了...</p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午12.07.50.png"></p><p>从上面的图中可以看到，tuning 一次 MobileNet，在 V100 上面都要花差不多 19 个小时，非常缓慢。在我们实验室这种显卡上面，大概就要两到三天了。</p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午4.16.54.png"></p><p>在 2019 年 12 月 5 日结束的<a href="https://sampl.cs.washington.edu/tvmconf/">第二届TVM与深度学习编译器会议</a>上面，也有一个思路类似的 talk。是来自 AWS 的 <a href="https://sampl.cs.washington.edu/tvmconf/slides/2019/E07-Cody-Yu.pdf">Improving AutoTVM Efficiency by Schedule Sharing</a>。跟上面的那篇文章非常类似，也是用聚类去优化 AutoTVM。 从上面的图中可以看出，对于每个从模型中抽取的 task，都要进行 turning。这个工作的动机是，如果一个 schedule 在一个 conv2d 上面效果良好，那他在另一个 conv2d 上面的效果应该也还不错。这意味着可以利用一些有代表性的任务来 turning，然后把该任务的 schedule 直接迁移到相似的任务上面去。这里的距离计算方式是 turning space 的重叠比率，然后利用这个距离来聚类。</p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午3.46.39.png"></p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午3.46.54.png"></p><p>从上面这个图中可以看出，Schedule Sharing 可以在平均 28% 的调整时间里获得 84% 的加速效果。相关讨论和 PR 在 <a href="https://github.com/apache/incubator-tvm/issues/4188">github issue</a> 上面可以找到。 新的搜索方法，还有一篇 <a href="https://arxiv.org/abs/1909.10616">Compiler-Level Matrix Multiplication Optimization for Deep Learning, arXiv</a>。这篇文章只把问题限制在了调 MM 的 tile size 上面，整个搜索空间与问题范围缩小了很多，而且去掉了 cost model，直接用强化学习来指导搜索，其实就相当于有一个很慢但是很准确的 cost model，跟前面讲的第一篇非常相似。（虽然这个 cost model 可能比 XGB 慢了差不多 1000 倍吧 XD） 总结一下上面的几个工作，几乎都是采取了一些很简单的做法，就对 AutoTVM 的整个 turning 时间起到了巨大的提升。说明这方面研究的潜力还是非常大的，如果能压缩到五分钟 turning 完一个网络，说不定就可以用 AutoTVM 来帮助 training。（当然现在来看还都是空谈，因为最好的工作也就是四到五倍的压缩效率，从两天变成半天）</p><p>说完了对搜索方法和训练采样方法的一些魔改方法之后，下面应该要说一些对于 AutoTVM 的核心 cost model 的魔改方法了。 目前对于 cost model 的研究集中于 GNN 上面，<a href="https://sampl.cs.washington.edu/tvmconf/">第二届TVM与深度学习编译器会议</a>上面有一个 UW 的 Talk，题目是 <a href="https://sampl.cs.washington.edu/tvmconf/slides/2019/E01-Eddie-Yan.pdf">Graph Convolutional Cost Models for TVM</a> ，还有一篇 <a href="https://arxiv.org/abs/1904.11876">Simulating Execution Time of Tensor Programs using Graph Neural Networks，ICLR 2019 workshop at Representation Learning on Graphs and Manifolds</a>。这两个工作基本是一样的，都是用 GCN 去优化 cost model。然而怪异的是两个工作的结果都是跟 XGB 在一个类似于估计运行时间的数据集上面的对比，没有最后 end-to-end 的效果提升。 两个工作都是用 AST 建图，大概长这样：</p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午4.19.55.png"></p><p>然后用 GCN 求一下 embedding，然后把所有 embedding 都平均一下，然后接个 MLP...</p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午4.33.14.png"></p><p>然后没了。</p><p><img src="/2020/01/02/autotvm-3/屏幕快照-2020-01-02-下午4.35.55.png"></p><p>这效果看起来其实也就那样，而且还没测 end-to-end 的性能，估计是实在不能看。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于目前的优化算法来说，依然存在着许多问题。但是后续的工作并不是特别多。首先可以看一下 &lt;a href=&quot;https://arxiv.org/abs/1905.12799&quot;&gt;Reinforcement Learning and Adaptive Sampling for Optimized DNN Compilation, ICML 2019 Workshop RL4RealLife&lt;/a&gt; 这篇文章主要谈到的问题是两点：1. 开发一个更有效的搜索算法（相对于 AutoTVM 的模拟退火） 2. 减少硬件测试的时间。从这篇文章的实验结果来看，第一个目标基本上没有达成，第二个目标完成的还不错。这个第二个目标也是我认为的之后优化的核心问题。 文章的整个框架如下图，主要贡献是两个蓝色的部分——基于强化学习的搜索和自适应采样。&lt;/p&gt;</summary>
    
    
    
    <category term="system" scheme="https://reku1997.gitee.io/categories/system/"/>
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/system/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="TVM" scheme="https://reku1997.gitee.io/tags/TVM/"/>
    
    <category term="AutoTVM" scheme="https://reku1997.gitee.io/tags/AutoTVM/"/>
    
  </entry>
  
  <entry>
    <title>AutoTVM 探秘（二）</title>
    <link href="https://reku1997.gitee.io/2019/12/31/autotvm-2/"/>
    <id>https://reku1997.gitee.io/2019/12/31/autotvm-2/</id>
    <published>2019-12-31T06:02:40.000Z</published>
    <updated>2021-12-16T12:08:27.671Z</updated>
    
    <content type="html"><![CDATA[<p>好了，本篇开始进入正题！内容基本都来自于：<a href="https://arxiv.org/abs/1805.08166">Learning to Optimize Tensor Programs. NeurlPS`18</a></p><span id="more"></span><h2 id="问题定义">问题定义</h2><p><a href="https://reku1997.gitee.io/2019/12/30/autotvm-1/">上一篇文章</a>讲了 AutoTVM 的大致问题，现在给出数学上面的描述。 首先有一个 <span class="math inline">\(\mathcal{E}\)</span> 代表所有可能的计算，<span class="math inline">\(e\in\mathcal{E}\)</span> 就是我们要去优化的计算。对于这个 <span class="math inline">\(e\)</span> 来说，有一个合法的 schedule space 叫 <span class="math inline">\(\mathcal{S}_e\)</span>，其中每个合法的 schedule 就叫 <span class="math inline">\(s\in\mathcal{S}_e\)</span>。<span class="math inline">\(x=g(e,s)\)</span> 是 <span class="math inline">\(e\)</span> 跟 <span class="math inline">\(s\)</span> 通过编译器 <span class="math inline">\(g\)</span> 生成的 low-level code，<span class="math inline">\(f(x)\)</span> 为这个 <span class="math inline">\(x\)</span> 在硬件上面实际运行的时间，那么该问题的定义则变成：<span class="math display">\[\underset{s\in\mathcal{S}_e}{\operatorname{argmin}}f(g(e,s))\]</span></p><p>这个问题跟现在很多人研究的 hyper-parameter optimization 非常相似，然而 paper 的作者认为，该问题跟传统的 hyper-parameter optimization 有以下几个区别： 第一个区别就是 tensor optimization 比传统的 hyper-parameter optimization 要快很多。因为超参数搜索优化的目标是神经网络的效果，所以训练一次其实是非常慢的，所以超参数搜索可以尝试很多很复杂的方法来进行优化。（比如 GP-UCB 这种，一次 GP kernel regression 要对一个协方差矩阵求逆，实际上是非常慢的，在<a href="https://www.zhihu.com/question/33711002">为什么基于贝叶斯优化的自动调参没有大范围使用？</a>上面有一定的讨论）而 tensor optimization 这个问题，其实你把真的 tensor 程序放到机器上面跑，最慢其实也就几秒。结果你搞了个复杂的方法，要好久才能预测出来结果，那我还不如真的把程序直接放在机器上面跑呢。不过这样的好处是我们可以获得比超参数搜索多得多的数据。 第二个重大的区别是，对于 hyper-parameter optimization 来说，神经网络就是个黑盒子，我们只能根据一些概率的理论去乱调。而对于 tensor optimization 来说，我们有 AST，这是一个非常有力的信息，因为一切运算的秘密其实都隐藏在 AST 里面。 第三个区别是，tensor optimization 的任务之间其实都是相似的，可以进行 transfer learning。 在上一篇文章中我们看到，其实可能去调整的参数还是很多的，这些参数乘起来会变成非常巨大的搜索空间 <span class="math inline">\(\mathcal{S}_e\)</span>。我们的目的就是在这个巨大的搜索空间中找到最好的 <span class="math inline">\(s\)</span>。</p><h2 id="搜索框架">搜索框架</h2><p>paper 作者提出的框架是，先搞一个 cost model <span class="math inline">\(\hat{f}(x)\)</span>，然后用这个 <span class="math inline">\(\hat{f}(x)\)</span> 去指导搜索出 <span class="math inline">\(s_i\)</span>，再把 <span class="math inline">\((e_i, s_i)\)</span> 放到机器上面跑造出 <span class="math inline">\(c_i\)</span>，然后再去更新 <span class="math inline">\(\hat{f}(x)\)</span>。</p><p><img src="/2019/12/31/autotvm-2/屏幕快照-2019-12-30-下午9.28.57.png"></p><p>对于这个 cost model，作者搞了两种实现。第一种是陈天奇的传统艺能——XGBoost，第二种是 TreeGRU。（顾名思义，以前的 GRU 或者 LSTM 都是一个输入，这个有多个输入，然后公式小变了一下，其实都大差不差）因为在实际的运用中，TreeGRU 实在是速度有点不行，所以根本都没有 merge 到 master 上面去，在 github 上面版本其实只有 XGBoost。 很显然，这个 cost model 的输出应该是一个预测该程序在硬件上运行的时间。对于最后的 loss，作者也实现了两种方式，第一种是传统的 regression loss：<span class="math display">\[\sum_i(\hat{f}(x_i)-c_i)^2\]</span></p><p>第二种则是只考虑他们的相对快慢：<span class="math display">\[\sum_{i,j}log(1+e^{-sign(c_i-c_j)(\hat{f}(x_i)-\hat{f}(x_j))})\]</span></p><p>实验表明，两种 loss 效果差不多。 因为这个搜索空间 <span class="math inline">\(\mathcal{S}_e\)</span> 很大，我们不能枚举整个空间。这里作者使用的方法是，先在 cost model 的指导下通过模拟退火搞出一个候选集，然后再选出来一个相对比较优的集合在硬件上面进行测试，最后更新 cost model。 那么要如何定义一个相对比较优的集合呢？这个集合要同时兼顾 quality 和 diversity。作者给出的最大化式子是这样的：<span class="math display">\[L(S)=-\sum_{s\in\mathcal{S}}\hat{f}(g(e,s))+\alpha\sum_{j=1}^m\left|{\cup_{s\in\mathcal{S}}\{s_j\}}\right|\]</span></p><p>这个东西如果不看代码，其实很难知道他到底在干什么东西。看过代码就知道这个 <span class="math inline">\(s\)</span> 其实已经经过特征抽取，被平铺为一个向量了，然后 <span class="math inline">\(m\)</span> 就是把这个平铺的向量切成 <span class="math inline">\(m\)</span> 段。这个式子的意义就是，使得每个子段都尽可能的不一样，并且运行速度还要尽量小。 为什么这个式子要设计成这个样子，看起来不是非常奇怪吗？而且这个式子要怎么优化呢？其实原因就在于如何优化这个式子上面，这个式子是一个 submodular function，可以通过贪心求一个还算凑合的近似解，具体可以看<a href="https://www.zhihu.com/question/34720027">怎么理解次模函数 submodular function？</a> 整个算法的大致过程如下：</p><p><img src="/2019/12/31/autotvm-2/屏幕快照-2019-12-30-下午9.44.16.png"></p><h2 id="贝叶斯优化">贝叶斯优化</h2><p>对于超参数搜索来说，最广为应用的方式就是贝叶斯优化。那么这个问题能不能套贝叶斯优化呢？在文章中，作者通过 bootstrap 搞出好几个 GBDT，然后通过在多个 GBDT 上面输出的预测值来采取 EI 或者 UCB 等函数，再通过上面的那种过程搜索函数的最值。虽然看起来有些奇怪（GP-UCB 那种其实是可以求出 UCB 的解析解），但总体来说其实还是符合贝叶斯优化的精神的。但是实验效果表明，用不用贝叶斯优化，效果其实都差不太多。</p><h2 id="迁移学习">迁移学习</h2><p>他这个迁移学习模块，我觉得写的其实有点奇怪。后面做的实验也不过是对于不同 size 的卷积进行了迁移学习。然而实际上卷积运算的形式是固定的，cost model 测试的也是同一台机器上面的运算速度，所以其实相当于用的就是同一个 cost model，这个东西本身就是通用的。从这个角度看，把 AST 抽取成一个固定长度的特征就是自然而然的。</p><p><img src="/2019/12/31/autotvm-2/屏幕快照-2019-12-31-下午2.00.14.png"></p><p>对于 XGB 来说，就是简单的抽取 AST 中循环变量所代表的 touched memory 和 outer loop length，在文章中这个叫做 context feature。然而问题在于不同的算子循环变量的数量都有可能是不同的，于是在 transfer learning 中，在代码中使用了一种叫 curve sample 的技术，实际上就是采样 context features 变成一个长度固定的 context relation feature。然而为什么这样就可以提高 transfer learning 的效果，其实我也搞的不太清楚。 在 TreeGRU 中，采取的方式是将循环变量的 context feature 通过 TreeGRU fold 起来，从而得到整个 AST 的 embedding。</p><h2 id="实验效果">实验效果</h2><p>中间那些不同方式的对比实验就不拿出来贴了，反正最后 state of art 是采用 rank loss 的 XGB。这里贴一个端到端的结果：</p><p><img src="/2019/12/31/autotvm-2/屏幕快照-2019-12-30-下午10.57.23.png"></p><p>从结果可以看出，优化效果非常强劲，而且越是那种非 benchmark 的网络（如 DQN），优化效果越好。 当然，这个方法并不是完美的，下一篇文章将陈述一些该方法的问题，并讲解几个 AutoTVM 方向最新的文章与成果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好了，本篇开始进入正题！内容基本都来自于：&lt;a href=&quot;https://arxiv.org/abs/1805.08166&quot;&gt;Learning to Optimize Tensor Programs. NeurlPS`18&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="system" scheme="https://reku1997.gitee.io/categories/system/"/>
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/system/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="TVM" scheme="https://reku1997.gitee.io/tags/TVM/"/>
    
    <category term="AutoTVM" scheme="https://reku1997.gitee.io/tags/AutoTVM/"/>
    
  </entry>
  
  <entry>
    <title>AutoTVM 探秘（一）</title>
    <link href="https://reku1997.gitee.io/2019/12/30/autotvm-1/"/>
    <id>https://reku1997.gitee.io/2019/12/30/autotvm-1/</id>
    <published>2019-12-30T12:34:03.000Z</published>
    <updated>2020-07-20T08:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>周末要在实验室搞个类似讲座之类的东西，先在这里写一下讲座内容，理清思路。也是对最近一个月的学习内容做一个总结。</p><span id="more"></span><h2 id="从-tvm-开始">从 TVM 开始</h2><p><a href="https://arxiv.org/abs/1802.04799">TVM: an automated end-to-end optimizing compiler for deep learning. OSDI`18</a> AutoTVM 其实是 TVM 的一个组件，那么先要搞清楚 TVM 是个啥。</p><blockquote><p>Apache TVM (incubating) is a compiler stack for deep learning systems. It is designed to close the gap between the productivity-focused deep learning frameworks, and the performance- and efficiency-focused hardware backends. TVM works with deep learning frameworks to provide end to end compilation to different backends.</p></blockquote><p>简单来说，这是一个深度学习编译器。输入是 high-level DL program (Pytorch TensorFlow etc.) 输出是 low-level optimized code。</p><p><img src="/2019/12/30/autotvm-1/屏幕快照-2019-12-30-下午4.08.45.png"></p><p>本文章的主题其实就是图里面蓝色的那个 Machine Learning-Based Automated Optimizer。 不过在进入主题之前先谈一谈这个 TVM 的意义吧，通过 TVM 的意义其实我们就可以自然的了解到为什么我们需要 AutoTVM。这些内容其实在之前的两篇文章里面都有谈过。 在之前很多厂商都搞过深度学习编译器，比如 TensorFlow XLA、NVIDIA TensorRT 等等。之前的搞法通常都是先把这些乱七八糟深度学习框架前端统一成一个 Graph IR，再对这个 Graph IR 进行一些例如 Operator Fusion 和 Constant Folding 之类的优化，然后将 Graph IR 映射到 XLA 算子或者 cuDNN 中，这些算子很多是由专业的工程师进行手工优化，效果拔群，通过这个过程实现神经网络的高效。 问题在于，你的模型需要在一大坨设备上面跑（比如手机、树莓派、GPU、CPU...）这些设备的运算能力和优化方式都有所不同，那么就需要每个设备都搞一个编译框架，然后由很多很多工程师去实现很多高效的算子用来映射。一个更夸张的发展趋势是，很多 AI 芯片厂商会把一些常用算子（如卷积层）直接设计一个硬件模块去加速，这样会导致只要出一个牛逼网络，那 AI 芯片就会多做一个模块去对网络的某些公共运算进行加速，然后工程师也会设计相关的算子，不停加班，永不失业。 还有个问题就是，比如 Operator Fusion 这种优化，有一些算子（如卷积+池化+relu）的融合模块已经在 cuDNN 中写好了，那么 Operator Fusion 的时候就可以直接对应过去。但是随着 DL 的发展，越来越多算子都可能进行融合，但是因为底层的实现还没做好，导致在图级别的优化会出现捉襟见肘的情况。很多时候优化会倾向于使用成熟的算子，避免那些还没有优化很好的融合方式。 以及一个在 learning 领域广泛出现的问题——长尾分布。对于那些通用的优化来说，优化一下可以产生很大的性能提升，但是对于那些长尾的优化来说，优化一次的代价过高，产生的利益也没有那么丰厚。 显然，解决问题的核心就在于如何对不同的硬件和不同的算子进行一波通用的优化。</p><h2 id="autotvm-初探">AutoTVM 初探</h2><p>对于上面这个问题，TVM 给我们的答案是 AutoTVM，一个 Automating Optimization。 在谈论这个问题之前，我们还要再复习一下体系结构的内容。其实这个在前两篇文章中也讲过很多。</p><p><img src="/2019/12/30/autotvm-1/屏幕快照-2019-12-30-下午4.44.18.png"></p><p>一个简单的 CPU 架构可以概括为上面这样，这个 CPU 有两个核心，每个核心都有自己 L12 cache，然后也支持 SIMD，也就是 fetch 一个指令可以在两个 PU 上面运算。当然现在很多处理器都支持超线程，也就是说一个核心有两个硬件线程，每个核心在操作系统中其实是两个核心。然后现在最厉害的 SIMD 指令叫做 AVX-512，可以在每个 cycle 同时对 16 个 float32 进行运算。 所以对于 CPU 而言，最为常用的优化其实就是三种：Parallelization（多核并行）、Vectorization（SIMD）、Cache。还有一些诸如是否进行循环展开之类的优化。 下面用 TVM 实现一个最简单的矩阵乘法，程序来自于 <a href="https://docs.tvm.ai/tutorials/autotvm/tune_simple_template.html#sphx-glr-tutorials-autotvm-tune-simple-template-py">AutoTVM 教程</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matmul_v0</span>(<span class="params">N, L, M, dtype</span>):</span></span><br><span class="line">    A = tvm.placeholder((N, L), name=<span class="string">&#x27;A&#x27;</span>, dtype=dtype)</span><br><span class="line">    B = tvm.placeholder((L, M), name=<span class="string">&#x27;B&#x27;</span>, dtype=dtype)</span><br><span class="line"></span><br><span class="line">    k = tvm.reduce_axis((<span class="number">0</span>, L), name=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    C = tvm.compute((N, M), <span class="keyword">lambda</span> i, j: tvm.<span class="built_in">sum</span>(A[i, k] * B[k, j], axis=k), name=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    s = tvm.create_schedule(C.op)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># schedule</span></span><br><span class="line">    y, x = s[C].op.axis</span><br><span class="line">    k = s[C].op.reduce_axis[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    yo, yi = s[C].split(y, <span class="number">8</span>)</span><br><span class="line">    xo, xi = s[C].split(x, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    s[C].reorder(yo, xo, k, yi, xi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s, [A, B, C]</span><br></pre></td></tr></table></figure><p>上面的程序只包括了 Cache 优化，方式就是常见的矩阵乘法循环变量 reorder 和矩阵分块。注意，这里矩阵分块的 magic number 是 8, 也就是说把这个矩阵分成 8*8 的小块，使得 cache 的 hit rate 更高。 但是对于这样的 magic number，没有经验的人是很难找到最优的数值的。而且这个数值跟很多硬件因素都有关系，很多时候我们不能对硬件的所有因素都产生全面的了解，这个时候就需要 AutoTVM 的帮助了。 用起来也很简单，其实就是指名一下哪些参数需要搜索。比如下面的程序就是指明要搜索 tile size：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@autotvm.template</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matmul</span>(<span class="params">N, L, M, dtype</span>):</span></span><br><span class="line">    A = tvm.placeholder((N, L), name=<span class="string">&#x27;A&#x27;</span>, dtype=dtype)</span><br><span class="line">    B = tvm.placeholder((L, M), name=<span class="string">&#x27;B&#x27;</span>, dtype=dtype)</span><br><span class="line"></span><br><span class="line">    k = tvm.reduce_axis((<span class="number">0</span>, L), name=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    C = tvm.compute((N, M), <span class="keyword">lambda</span> i, j: tvm.<span class="built_in">sum</span>(A[i, k] * B[k, j], axis=k), name=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    s = tvm.create_schedule(C.op)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># schedule</span></span><br><span class="line">    y, x = s[C].op.axis</span><br><span class="line">    k = s[C].op.reduce_axis[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">##### define space begin #####</span></span><br><span class="line">    cfg = autotvm.get_config()</span><br><span class="line">    cfg.define_split(<span class="string">&quot;tile_y&quot;</span>, y, num_outputs=<span class="number">2</span>)</span><br><span class="line">    cfg.define_split(<span class="string">&quot;tile_x&quot;</span>, x, num_outputs=<span class="number">2</span>)</span><br><span class="line">    <span class="comment">##### define space end #####</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># schedule according to config</span></span><br><span class="line">    yo, yi = cfg[<span class="string">&quot;tile_y&quot;</span>].apply(s, C, y)</span><br><span class="line">    xo, xi = cfg[<span class="string">&quot;tile_x&quot;</span>].apply(s, C, x)</span><br><span class="line"></span><br><span class="line">    s[C].reorder(yo, xo, k, yi, xi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s, [A, B, C]</span><br></pre></td></tr></table></figure><p>这其实也是系统设计的艺术，首先 TVM 把运算与 schedule 进行解耦，然后一部分 schedule 由用户进行实现，一部分需要精细调整的内容由一个 ML 算法进行搜索，从而达到一个易用性和性能的 trade-off。相对应的是 Facebook 做的 Tensor Comprehension，要解决的问题跟 TVM 是类似的，但是选择的是利用 polyhedra model 进行一个类似端到端的优化过程，但是优化的空间其实比 TVM 这种 schedule space 模型要差一些，所以效果也会打些折扣。一些相关的讨论可以在<a href="https://www.zhihu.com/question/267167829">如何看待Tensor Comprehensions？与TVM有何异同？</a>上面看到。 对于 GPU 来说，由于架构跟 CPU 存在区别，所以优化的方式也不太一样：</p><p><img src="/2019/12/30/autotvm-1/屏幕快照-2019-12-30-下午8.07.07.png"></p><p><img src="/2019/12/30/autotvm-1/屏幕快照-2019-12-30-下午8.27.33.png"></p><p>可以看到，相对 CPU 来说，GPU 多了很多可以向量化的计算单元，甚至还有 Tensor Core 可以对计算进行张量化。而且 L1 cache 可以由程序员来进行主动的控制，作为线程之间的缓存，提供了很大的自由性。 在 GPU 里面还有线程与线程块的概念。几个 thread 会统一放到一个 block 中。同一个 block 中的线程会共享同一个 L1 cache 或者 shared memory，合理的分配 shared memory 会显著减少读写时间。 在 GPU 上面优化矩阵乘法，我们可以这样写，代码来自 <a href="http://tvm.d2l.ai/chapter_gpu_schedules/matmul.html">Dive in DL Compiler</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matmul_gpu</span>(<span class="params">n</span>):</span></span><br><span class="line">    A, B, C = d2ltvm.matmul(n, n, n)</span><br><span class="line">    s = tvm.create_schedule(C.op)</span><br><span class="line">    <span class="comment"># Create caches</span></span><br><span class="line">    A_shared = s.cache_read(A, <span class="string">&quot;shared&quot;</span>, [C])</span><br><span class="line">    A_local  = s.cache_read(A_shared, <span class="string">&quot;local&quot;</span>, [C])</span><br><span class="line">    B_shared = s.cache_read(B, <span class="string">&quot;shared&quot;</span>, [C])</span><br><span class="line">    B_local  = s.cache_read(B_shared, <span class="string">&quot;local&quot;</span>, [C])</span><br><span class="line">    C_local = s.cache_write(C, <span class="string">&quot;local&quot;</span>)</span><br><span class="line">    <span class="comment"># Split each axis into block axis, thread axis, and inner axis</span></span><br><span class="line">    x, y = s[C].op.axis</span><br><span class="line">    xb, xo, xi = split(s[C], x, (block_size, tx))</span><br><span class="line">    yb, yo, yi = split(s[C], y, (block_size, ty))</span><br><span class="line">    s[C].reorder(xb, yb, xo, yo, xi, yi)</span><br><span class="line">    <span class="comment"># Note that we bind yb to blockIdx.x instead of blockIdx.y</span></span><br><span class="line">    bind_thread(s[C], (yb, xb, yo, xo),</span><br><span class="line">                (<span class="string">&quot;blockIdx.x&quot;</span>, <span class="string">&quot;blockIdx.y&quot;</span>, <span class="string">&quot;threadIdx.x&quot;</span>, <span class="string">&quot;threadIdx.y&quot;</span>))</span><br><span class="line">    <span class="comment"># Schedule C_local</span></span><br><span class="line">    s[C_local].compute_at(s[C], yo)</span><br><span class="line">    yi, xi = s[C_local].op.axis</span><br><span class="line">    k, = s[C_local].op.reduce_axis</span><br><span class="line">    ko, ki = s[C_local].split(k, tk)</span><br><span class="line">    s[C_local].reorder(ko, ki, yi, xi)</span><br><span class="line">    <span class="comment"># Optimize read caches of A and B with cooperative fetching</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize_read_cache</span>(<span class="params">shared, local</span>):</span></span><br><span class="line">        s[shared].compute_at(s[C_local], ko)</span><br><span class="line">        s[local].compute_at(s[C_local], ki)</span><br><span class="line">        y, x = s[shared].op.axis</span><br><span class="line">        <span class="comment"># Note that we must split into block_size parts to reuse</span></span><br><span class="line">        <span class="comment"># the previous axis threads</span></span><br><span class="line">        yo, yi = s[shared].split(y, nparts=block_size)</span><br><span class="line">        xo, xi = s[shared].split(x, nparts=block_size)</span><br><span class="line">        s[shared].reorder(yo, xo, yi, xi)</span><br><span class="line">        bind_thread(s[shared], (yo, xo), (<span class="string">&quot;threadIdx.y&quot;</span>, <span class="string">&quot;threadIdx.x&quot;</span>))</span><br><span class="line">    optimize_read_cache(A_shared, A_local)</span><br><span class="line">    optimize_read_cache(B_shared, B_local)</span><br><span class="line">    <span class="keyword">return</span> s, (A, B, C)</span><br></pre></td></tr></table></figure><p>看起来有点复杂，其实就是 shared memory 的一些分配。从代码中可以看到，有很多 split 的操作，事实上对于缺乏经验的工程师来说，确定这些 split size 是非常困难的。 在 <a href="https://docs.tvm.ai/tutorials/autotvm/tune_conv2d_cuda.html">AutoTVM 教程</a>中我们可以找到一个相对通用的模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@autotvm.template</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d_no_batching</span>(<span class="params">N, H, W, CO, CI, KH, KW, stride, padding</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> N == <span class="number">1</span>, <span class="string">&quot;Only consider batch_size = 1 in this template&quot;</span></span><br><span class="line"></span><br><span class="line">    data = tvm.placeholder((N, CI, H, W), name=<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">    kernel = tvm.placeholder((CO, CI, KH, KW), name=<span class="string">&#x27;kernel&#x27;</span>)</span><br><span class="line">    conv = topi.nn.conv2d_nchw(data, kernel, stride, padding, dilation=<span class="number">1</span>, out_dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    s = tvm.create_schedule([conv.op])</span><br><span class="line"></span><br><span class="line">    <span class="comment">##### space definition begin #####</span></span><br><span class="line">    n, f, y, x = s[conv].op.axis</span><br><span class="line">    rc, ry, rx = s[conv].op.reduce_axis</span><br><span class="line"></span><br><span class="line">    cfg = autotvm.get_config()</span><br><span class="line">    cfg.define_split(<span class="string">&quot;tile_f&quot;</span>, f, num_outputs=<span class="number">4</span>)</span><br><span class="line">    cfg.define_split(<span class="string">&quot;tile_y&quot;</span>, y, num_outputs=<span class="number">4</span>)</span><br><span class="line">    cfg.define_split(<span class="string">&quot;tile_x&quot;</span>, x, num_outputs=<span class="number">4</span>)</span><br><span class="line">    cfg.define_split(<span class="string">&quot;tile_rc&quot;</span>, rc, num_outputs=<span class="number">3</span>)</span><br><span class="line">    cfg.define_split(<span class="string">&quot;tile_ry&quot;</span>, ry, num_outputs=<span class="number">3</span>)</span><br><span class="line">    cfg.define_split(<span class="string">&quot;tile_rx&quot;</span>, rx, num_outputs=<span class="number">3</span>)</span><br><span class="line">    cfg.define_knob(<span class="string">&quot;auto_unroll_max_step&quot;</span>, [<span class="number">0</span>, <span class="number">512</span>, <span class="number">1500</span>])</span><br><span class="line">    cfg.define_knob(<span class="string">&quot;unroll_explicit&quot;</span>, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="comment">##### space definition end #####</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># inline padding</span></span><br><span class="line">    pad_data = s[conv].op.input_tensors[<span class="number">0</span>]</span><br><span class="line">    s[pad_data].compute_inline()</span><br><span class="line">    data, raw_data = pad_data, data</span><br><span class="line"></span><br><span class="line">    output = conv</span><br><span class="line">    OL = s.cache_write(conv, <span class="string">&#x27;local&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create cache stage</span></span><br><span class="line">    AA = s.cache_read(data, <span class="string">&#x27;shared&#x27;</span>, [OL])</span><br><span class="line">    WW = s.cache_read(kernel, <span class="string">&#x27;shared&#x27;</span>, [OL])</span><br><span class="line">    AL = s.cache_read(AA, <span class="string">&#x27;local&#x27;</span>, [OL])</span><br><span class="line">    WL = s.cache_read(WW, <span class="string">&#x27;local&#x27;</span>, [OL])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tile and bind spatial axes</span></span><br><span class="line">    n, f, y, x = s[output].op.axis</span><br><span class="line">    bf, vf, tf, fi = cfg[<span class="string">&quot;tile_f&quot;</span>].apply(s, output, f)</span><br><span class="line">    by, vy, ty, yi = cfg[<span class="string">&quot;tile_y&quot;</span>].apply(s, output, y)</span><br><span class="line">    bx, vx, tx, xi = cfg[<span class="string">&quot;tile_x&quot;</span>].apply(s, output, x)</span><br><span class="line">    kernel_scope = n  <span class="comment"># this is the scope to attach global config inside this kernel</span></span><br><span class="line"></span><br><span class="line">    s[output].bind(bf, tvm.thread_axis(<span class="string">&quot;blockIdx.z&quot;</span>))</span><br><span class="line">    s[output].bind(by, tvm.thread_axis(<span class="string">&quot;blockIdx.y&quot;</span>))</span><br><span class="line">    s[output].bind(bx, tvm.thread_axis(<span class="string">&quot;blockIdx.x&quot;</span>))</span><br><span class="line">    s[output].bind(vf, tvm.thread_axis(<span class="string">&quot;vthread&quot;</span>))</span><br><span class="line">    s[output].bind(vy, tvm.thread_axis(<span class="string">&quot;vthread&quot;</span>))</span><br><span class="line">    s[output].bind(vx, tvm.thread_axis(<span class="string">&quot;vthread&quot;</span>))</span><br><span class="line">    s[output].bind(tf, tvm.thread_axis(<span class="string">&quot;threadIdx.z&quot;</span>))</span><br><span class="line">    s[output].bind(ty, tvm.thread_axis(<span class="string">&quot;threadIdx.y&quot;</span>))</span><br><span class="line">    s[output].bind(tx, tvm.thread_axis(<span class="string">&quot;threadIdx.x&quot;</span>))</span><br><span class="line">    s[output].reorder(n, bf, by, bx, vf, vy, vx, tf, ty, tx, fi, yi, xi)</span><br><span class="line">    s[OL].compute_at(s[output], tx)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tile reduction axes</span></span><br><span class="line">    n, f, y, x = s[OL].op.axis</span><br><span class="line">    rc, ry, rx = s[OL].op.reduce_axis</span><br><span class="line">    rco, rcm, rci = cfg[<span class="string">&#x27;tile_rc&#x27;</span>].apply(s, OL, rc)</span><br><span class="line">    ryo, rym, ryi = cfg[<span class="string">&#x27;tile_rx&#x27;</span>].apply(s, OL, ry)</span><br><span class="line">    rxo, rxm, rxi = cfg[<span class="string">&#x27;tile_ry&#x27;</span>].apply(s, OL, rx)</span><br><span class="line">    s[OL].reorder(rco, ryo, rxo, rcm, rym, rxm, rci, ryi, rxi, n, f, y, x)</span><br><span class="line"></span><br><span class="line">    s[AA].compute_at(s[OL], rxo)</span><br><span class="line">    s[WW].compute_at(s[OL], rxo)</span><br><span class="line">    s[AL].compute_at(s[OL], rxm)</span><br><span class="line">    s[WL].compute_at(s[OL], rxm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cooperative fetching</span></span><br><span class="line">    <span class="keyword">for</span> load <span class="keyword">in</span> [AA, WW]:</span><br><span class="line">        n, f, y, x = s[load].op.axis</span><br><span class="line">        fused = s[load].fuse(n, f, y, x)</span><br><span class="line">        tz, fused = s[load].split(fused, nparts=cfg[<span class="string">&quot;tile_f&quot;</span>].size[<span class="number">2</span>])</span><br><span class="line">        ty, fused = s[load].split(fused, nparts=cfg[<span class="string">&quot;tile_y&quot;</span>].size[<span class="number">2</span>])</span><br><span class="line">        tx, fused = s[load].split(fused, nparts=cfg[<span class="string">&quot;tile_x&quot;</span>].size[<span class="number">2</span>])</span><br><span class="line">        s[load].bind(tz, tvm.thread_axis(<span class="string">&quot;threadIdx.z&quot;</span>))</span><br><span class="line">        s[load].bind(ty, tvm.thread_axis(<span class="string">&quot;threadIdx.y&quot;</span>))</span><br><span class="line">        s[load].bind(tx, tvm.thread_axis(<span class="string">&quot;threadIdx.x&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tune unroll</span></span><br><span class="line">    s[output].pragma(kernel_scope, <span class="string">&#x27;auto_unroll_max_step&#x27;</span>, cfg[<span class="string">&#x27;auto_unroll_max_step&#x27;</span>].val)</span><br><span class="line">    s[output].pragma(kernel_scope, <span class="string">&#x27;unroll_explicit&#x27;</span>, cfg[<span class="string">&#x27;unroll_explicit&#x27;</span>].val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s, [raw_data, kernel, conv]</span><br></pre></td></tr></table></figure><p>对于这些 knob，有个简单进行解释的图表： <img src="/2019/12/30/autotvm-1/屏幕快照-2020-01-02-上午11.37.17.png"></p><p>好了，现在对 AutoTVM 已经有了一些感性的理解了。不过这个开头写的有点多，以上内容先算一篇，下一篇我们讲 AutoTVM 的具体实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周末要在实验室搞个类似讲座之类的东西，先在这里写一下讲座内容，理清思路。也是对最近一个月的学习内容做一个总结。&lt;/p&gt;</summary>
    
    
    
    <category term="system" scheme="https://reku1997.gitee.io/categories/system/"/>
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/system/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="TVM" scheme="https://reku1997.gitee.io/tags/TVM/"/>
    
    <category term="AutoTVM" scheme="https://reku1997.gitee.io/tags/AutoTVM/"/>
    
  </entry>
  
  <entry>
    <title>CSE 599W: SYSTEMS FOR ML 课程笔记 7-12</title>
    <link href="https://reku1997.gitee.io/2019/11/21/cse-599w-systems-for-ml-7-12/"/>
    <id>https://reku1997.gitee.io/2019/11/21/cse-599w-systems-for-ml-7-12/</id>
    <published>2019-11-21T07:04:48.000Z</published>
    <updated>2021-12-16T11:33:10.164Z</updated>
    
    <content type="html"><![CDATA[<p>各种课程资料请参考<a href="https://reku1997.gitee.io/2019/11/08/cse-599w-systems-for-ml-1-6/">上一篇文章</a></p><span id="more"></span><h2 id="lecture-7-automatic-code-generation---tvm-stack">Lecture 7: Automatic Code Generation - TVM Stack</h2><p>现在深度学习的框架非常多，而这些乱七八糟框架写出来的代码通常又跑在乱七八糟的设备上。这其中最为关键的问题就是：如何让深度学习代码在不同的设备上都跑出最好的效果。 众所周知，如果软件架构出现了什么难以解决的问题，那就加个中间层，看看能不能解决。如果还不能解决，那就再加个中间层（ 目前各家（比如 TensorFlow XLA、NVIDIA TensorRT 等）采用的设计思路就是将各个框架写出来的网络转换成一种统一的表示形式，也就是所谓的 Graph IR。</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/1.png"></p><p>当然了，最后 IR 如果想要运行，那你还是要把 IR 变成机器码才可以。对于不同的硬件平台、数据格式、精度、线程结构都要写一堆不同的代码生成规则和优化规则。 这个问题是 TVM 的技术背景了。前面说了，如果还解决不了问题，那就再加个中间层。TVM 加的中间层就是所谓的 Tensor Expression Language 表示方法。这个 idea 来自于 Halide，核心在于把代码的计算和调度分开。</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/2.png"></p><p>举个具体的例子，最简单的一个向量相加，用 TVM 实现起来长这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C = tvm.compute((n,), <span class="keyword">lambda</span> i: A[i] + B[i])</span><br><span class="line">s = tvm.create_schedule(C.op)</span><br></pre></td></tr></table></figure><p>得到的 C 代码是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    C[i] = A[i] + B[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上一些额外的循环控制（就是上篇文章中讲的 cache 优化）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C = tvm.compute((n,), <span class="keyword">lambda</span> i: A[i] + B[i])</span><br><span class="line">s = tvm.create_schedule(C.op)</span><br><span class="line">xo, xi = s[C].split(s[C].axis[<span class="number">0</span>], factor=<span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>生成的代码就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> xo = <span class="number">0</span>; xo &lt; <span class="built_in">ceil</span>(n / <span class="number">32</span>); ++xo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> xi = <span class="number">0</span>; xi &lt; <span class="number">32</span>; ++xi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = xo * <span class="number">32</span> + xi;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i] = A[i] + B[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可以绑定特定的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C = tvm.compute((n,), <span class="keyword">lambda</span> i: A[i] + B[i])</span><br><span class="line">s = tvm.create_schedule(C.op)</span><br><span class="line">xo, xi = s[C].split(s[C].axis[<span class="number">0</span>], factor=<span class="number">32</span>)</span><br><span class="line">s[C].recorder(xi, xo)</span><br><span class="line">s[C].bind(xo, tvm.thread_axis(“blockIdx.x”)</span><br><span class="line">s[C].bind(xi, tvm.thread_axis(“threadIdx.x”)</span><br></pre></td></tr></table></figure><p>这样就出来一个 CUDA kernel 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = threadIdx.x * <span class="number">32</span> + blockIdx.x;</span><br><span class="line"><span class="keyword">if</span> (i &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">    C[i] = A[i] + B[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TVM 的核心就是一些调度原语，比如下图这些：</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/3.png"></p><p>还有 TVM 最有趣的部分 AutoTVM，可以用 learning 的方式对代码进行自动优化，不过这个东西在课程中并不是重点，所以只是简单的提及了一下。</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/4.png"></p><p>在我理解，TVM 就是一个 Graph IR 的优化框架，或者说是底层算子的高阶表示。</p><h2 id="lecture-8-hardware-specialization-in-deep-learning">Lecture 8: Hardware Specialization in Deep Learning</h2><p>这一讲主要介绍 TVM 技术栈中的重要部分 VTA。对于硬件我不是特别熟悉，也不是特别感兴趣，所以这章就随便看看了。 <a href="https://zhuanlan.zhihu.com/p/39635145">VTA: 开源AI芯片栈</a> Tianqi 的这篇文章概括性的讲述了 VTA 的意义。 总体来说，就是根据 RISC 的思想，设计了一套硬件架构。TVM 充当编译器，VTA 充当底层计算硬件，两者配合达到良好的效果。</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/5.png"></p><h2 id="lecture-9-memory-optimization">Lecture 9: Memory Optimization</h2><p>这一讲我觉得还蛮有意思的，讲的是深度学习的内存优化。 主要内容来自于这篇论文：<a href="https://arxiv.org/abs/1604.06174">Training Deep Nets with Sublinear Memory Cost</a> 这一讲的核心问题在于，为什么我们要用 autograd 来形成计算图，而不是直接使用 BP？</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/1-1.png"></p><p>这个问题的答案其实就本节课的标题：Memory Optimization。我们要优化内存的使用，所以要用计算图。 假如只有前向传播的话，我们其实可以通过计算图的层次结构来复用内存：</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/2-1.png"></p><p>这个内存复用有两个原则：Inplace 和 Normal Sharing。 所谓 Inplace 就是输出的内容直接存到输入内存的地方。Normal Sharing 则是重复使用那些不被需要的内存。 显然 Inplace 也有一些失效的时候，当输入的内容还被其他输出依赖时，我们之前的输出就不能使用这块内存。</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/3-1.png"></p><p>回到我们最开始的问题，为什么我们要用 autograd 的计算图来代替 BP？</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/4-1.png"></p><p>这个问题其实没有在 slides 中说清楚。看了看其他人的理解，都是觉得 BP 要存中间结果，所以比较费内存。但是计算图也要存中间结果啊？所以有点费解。我的理解是，计算图可以更好的捕获变量之间的依赖性，就像上面这个图一样。如果用 BP，每一步中间结果都要存起来，但是如果用 autograd，就可以全程 Inplace。 后面讲了一些利用两个原则优化内存的例子，都不是很难理解。但是问题在于，不管我们怎么复用，整体的空间复杂度仍然是线性增长的。</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/5-1.png"></p><p>这时候有个牛逼做法就是保存 <span class="math inline">\(\sqrt{N}\)</span> 个中间节点，每次需要反向传播的时候，就从这个中间节点往下算 <span class="math inline">\(\sqrt{N}\)</span> 步。这样内存就是 <span class="math inline">\(O(\sqrt{N})\)</span> 级别了，是不是跟 ICPC 竞赛里面常见的分块算法一模一样？ 感觉内存优化这部分还是有些东西不太清楚，需要回头看一下论文。看完论文补充一下这部分的内容。 接下来是 assignment 2。 这次作业感觉工作量还是很大的，首先是要满足作业的第一个要求，把 test_tvm_op.py 里面的所有测试都跑通：</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/1-2.png"></p><p>这一步主要要参考 <a href="https://docs.tvm.ai/index.html">TVM Documentation</a> 的写法，把这些算子都补齐。其中一些算子的作用还是比较迷惑的，要看测试才知道是什么意思。TVM 的写法有些地方也比较古怪，要自己慢慢尝试。 然后是满足第二个要求，跑通 mnist 的两个方法：</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/2-2.png"></p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/3-2.png"></p><p>这一步是要把 autodiff 的内容补全，其实很简单，但是有些地方可能不太清楚他到底想让你写什么东西，仔细看看调用代码，然后把函数补全就好了。 从上面的截图可以看出，我们自己写的算子效果非常垃圾，跑一遍 mlp 要 80s，下面就是如何优化矩阵乘法算子了：</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/4-2.png"></p><p>主要思路还是来自于 <a href="http://dlsys.cs.washington.edu/pdf/lecture6.pdf">Lecture 6</a>，只要简单的把矩阵分一下块，调整一下循环顺序，然后再并行一下，就可以得到 20x 的优化效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = tvm.create_schedule(C.op)</span><br><span class="line">xo, yo, xi, yi = s[C].tile(C.op.axis[<span class="number">0</span>], C.op.axis[<span class="number">1</span>], x_factor=<span class="number">32</span>, y_factor=<span class="number">64</span>)</span><br><span class="line">xk, yk = s[C].split(k, factor=<span class="number">8</span>)</span><br><span class="line">s[C].reorder(xo, yo, xk, xi, yi, yk)</span><br><span class="line">s[C].parallel(xo)</span><br><span class="line">s[C].unroll(yk)</span><br><span class="line">f = tvm.build(s, [A, B, C], tgt, target_host=tgt_host, name=func_name)</span><br></pre></td></tr></table></figure><p>更多精细的优化在 <a href="https://zhuanlan.zhihu.com/p/75203171">如何利用TVM快速实现超越Numpy的GEMM</a> 这篇文章中可以找到，非常牛逼。</p><h2 id="lecture-10-parallel-scheduling">Lecture 10: Parallel Scheduling</h2><p>在内存分配之后，第10讲讲的是并行调度的问题。 首先讲了一下 Model Parallel 和 Data Parallel 的模式，比较基础。</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/1-3.png"></p><p>因为现实的运算中存在着各种复杂的同步关系，所以我们需要一个自动调度器。 这个自动调度器需要调度各种各样的资源，包括数据、随机数生成器、网络通信等等；也要调度各种各样的操作。 对于深度学习来说，基于计算图的调度就非常自然。因为计算图是一个 DAG，各种依赖复用关系都非常明显。但是基于计算图的这种调度对于一些什么写后读、读后写的问题可能不是特别敏感，所以还增加需要 mutation aware 这种调度方式。</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/2-3.png"></p><p>后面给了一个很简单的队列调度的例子，看看就能懂。</p><h2 id="lecture-11-distributed-training-and-communication-protocols">Lecture 11: Distributed Training and Communication Protocols</h2><p>这一讲讲的主要是参数的 Synchronization 问题。 首先介绍了一种叫做 Allreduce 的操作，感觉就是在中间把分布式程序拦了一下：</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/3-3.png"></p><p>然后讲了几种网络拓扑对 Allreduce 操作的影响，看起来比较简单。 之后介绍了 Parameter Server，这个在实习的时候接触的蛮多，其实就是个 KV，用 PS 去更新和获取参数，他们内部甚至搞了个无锁 hash 表...</p><h2 id="lecture-12-model-serving">Lecture 12: Model Serving</h2><p>终于到了最后一讲，这一讲主要讲的是模型部署在现实应用中的问题。</p><p><img src="/2019/11/21/cse-599w-systems-for-ml-7-12/4-3.png"></p><p>主要分为模型压缩和服务系统两个部分来进行讲解。 模型压缩的第一个部分是矩阵/向量分解，这个矩阵分解套路很简单很常见，向量分解没见过，也没太看懂，有空可以仔细研究一下。大概是把一个 cnn 分解成几个 cnn，但是能达到相似的效果。 然后网络剪枝，其中一个思路是 prune the connections。想法很简单，每次增加前向传播的 theshold，减少连通性。 第二个思路是 weight sharing，首先对参数进行聚类，相似的参数就看做一个参数，再对他们进行统一的更新。 模型的低比特量化也是一个很有趣的思路，通过降低模型数据存储的精度，来压缩模型并且尽量保持精度。 还有知识蒸馏，用一个大模型去训练一个小模型。上周末实验室讲座有个大哥讲的就是这个内容，但是我因为家里有急事所以没听到，不过获得了 PPT，之后自己补一补吧。 第二个部分就是服务系统了，服务系统的目标是编写程序的灵活性、GPU 上面的高效率以及延迟满足 SLA（service-level agreement）。 然后讲了一个叫 Nexus 的系统，看起来有些难以理解，先略过吧~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;各种课程资料请参考&lt;a href=&quot;https://reku1997.gitee.io/2019/11/08/cse-599w-systems-for-ml-1-6/&quot;&gt;上一篇文章&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="system" scheme="https://reku1997.gitee.io/categories/system/"/>
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/system/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="learning" scheme="https://reku1997.gitee.io/tags/learning/"/>
    
    <category term="system" scheme="https://reku1997.gitee.io/tags/system/"/>
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSE 599W: Systems for ML 课程笔记 1-6</title>
    <link href="https://reku1997.gitee.io/2019/11/08/cse-599w-systems-for-ml-1-6/"/>
    <id>https://reku1997.gitee.io/2019/11/08/cse-599w-systems-for-ml-1-6/</id>
    <published>2019-11-08T07:31:51.000Z</published>
    <updated>2021-12-16T11:33:12.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dlsys.cs.washington.edu/">课程网站</a> 在头条 AML 实习的时候就觉得这个 AI system 方向非常有趣，但是苦于实验室不是搞这一套的，自己拖延症也非常严重，所以一直在入门的边缘徘徊。但是在今天——研一秋学期考试周的前一周，我决定开始学习 AI system 方向最著名的必学课程，Tianqi Chen 在 UW 开设的 CSE599W。 这个课程其实资料并不是很完善，只有 github 上面的几个 repo 和课程网站上面的 slide，缺乏讲课的视频资源。而且在开始学习之前就听说很多地方 slide 写的非常简陋，只能通过 tvm 和 tinyflow 代码慢慢学习。我在学习之前也找了一些 blog 资源，开个坑，希望可以努力坚持下来！ 本人的作业也开源到 <a href="https://github.com/wyc-ruiker/CSE-599W-2018">github</a> 上面了，希望大家多多指导。</p><span id="more"></span><p><a href="http://jcf94.com/2018/10/04/2018-10-04-cse559w/">Chenfan Blog——CSE 599W： Systems for ML</a></p><p><a href="https://zhuanlan.zhihu.com/c_186688444">知乎专栏：SysML/DL机器学习系统</a></p><p><a href="https://zhuanlan.zhihu.com/p/50529704">手把手带你遨游TVM</a></p><p>不过上面这两个参考资料，第一个有点过于简略，第二个虽然写的很好但是已经五个月没有更新了...可能是坑了，所以后面的内容还是要靠自己慢慢研究了... 第三篇是蓝色大大的 TVM 入门文章，写的非常赞，可以清晰的理解 TVM 存在的意义与解决的问题。</p><h2 id="lecture-1-2">Lecture 1-2</h2><p>介绍了一波深度学习的基本概念，常见的各种 CNN、RNN、激活函数、BatchNormal、梯度消失与梯度爆炸都用一节课介绍了一通。因为我之前学过 Ng 在 coursera 上面的 Deep learing 专项，所以对这些都很了解了，而且这些内容的资源满大街都是，就不在这里继续介绍了。 第二讲是一个实验课，用 mxnet 搭建一个基础的网络，虽然我之前系统看过沐神的《动手深度学习》，但是我看的是 github 上面的 pytorch 魔改版，mxnet 只在上半年的华为软挑的时候用过一下，不是特别了解。但是这个 gluon api 似乎跟 pytorch 大同小异，这里也不多废话了，有兴趣自己看看原版《动手深度学习》就好了。</p><h2 id="lecture-3-overview-of-deep-learning-system">Lecture 3: Overview of Deep Learning System</h2><p>学习过什么是 Deep Learning 了，那么啥是 Deep Learning System 呢？ 在我的理解其实就是从调包到真正计算出结果的全过程，就是 Deep Learning System，也就是通常所说的算法的真正落地。 在这个课程中，Deep Learning System 从高层到底层分成了三个部分：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-1.png"></p><p>第一部分就是调包的封装 API，第二部分表示调完包后对调包代码的优化与 Scheduling，第三部分就是最下面的一些高效的 GPU kernel 实现、不同硬件后端的部署等等。 那么一个 Deep Learning 框架在 API 层需要包括什么内容呢？为什么大家要用框架而不是自己从头写呢？ 下面这个图就回答了这个问题，现在的模型越来越大，实现起来需要注意的内容也就越来越多，如果每步都由我们自己来进行链式求导算梯度的话，可能就没有这么多转行深度学习的大哥了（</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-2.png"></p><p>计算图是一个 Deep Learning 框架的基本概念，节点表示运算操作，边表示数据依赖，这里展示了一个最简单的 Logistic Regression 计算图实例： 首先是计算 loss 之前的前向传播，其实就是一个最简单的矩阵乘法加一个 softmax：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-3.png"></p><p>然后是将 softmax 输出的东西搞一个交叉熵作为 loss，相当于最大化 liklihood:</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-4.png"></p><p>然后是自动微分：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-5.png"></p><p>最后通过 SGD 来更新梯度：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-6.png"></p><p>结合上面的所有步骤，我们就得到了一个计算图：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-7.png"></p><p>最上层的 API 做了最简单的介绍，下面就是中间的 System 部分，讲的是对计算图的优化和对计算的调度。 计算优化最简单的一种就是 memory 优化，比如增加 cache 利用率之类的。因为我们的代码通常跑在多个线程甚至多个计算设备上面，所以并行调度也是非常重要的。最简单的一种并行调度如下图，这是一个 mxnet 代码，因为计算 C 和计算 B 是完全独立的，所以这两个部分可以并行化。</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-8.png"></p><p>然后简单介绍一下最底层的情况，我们训练完了 model，要部署到不同的设备上。想必大家也都听过各种各样的厂商搞出过各种各样的部署方法，为了产生更好的模型性能：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-9.png"></p><p>TVM 就是为了解决这样的问题而诞生的，只要我们都搞成中间代码，全栈自动编译优化，这样 model 就可以非常简单的部署到不同的设备上了：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/3-10.png"></p><p>这门课将在接下来详细介绍 Deep Learning System 的三个部分。</p><h2 id="lecture-4-backpropagation-and-automatic-differentiation">Lecture 4: Backpropagation and Automatic Differentiation</h2><p>第四节课讲的是 Deep Learning 中的求导方式——Auto-Diff. 首先我们要了解现代计算机实现求导通常有哪些方式。 第一种叫做 Symbolic Differentiation，如图所示：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/4-1.png"></p><p>通过程序来维护整个求导的式子，然后把变量带入就得到最终的导数。这种做法的缺点在于表达式是一个很难维护的东西，最后要维护的东西就会越来越多。正常 Deep Learning 框架显然不应该选择这种求导方式... 第二种叫做 Numerical Differentiation，这种求导形式非常简单，看起来很适合计算机：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/4-2.png"></p><p>但是有个很关键的问题是，这种求导方法要进行两次正向传播，跑起来很慢，而且误差会比较大。但是因为其实现方式的简单，所以这是一个非常好的 grad check 工具。Ng 在 DL 专项里面也是用这种方式去进行 grad check 的。 第三种叫做 Backpropagation，现代 Deep Learning 的核心：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/4-3.png"></p><p>虽然这种做法很适合计算机，效率也不错。但有一个关键的问题，我们在做正向传播的时候要记录中间结果，这样才能在后面进行反向传播，内存耗费很大。而且难以形成计算图，无法进行通用的并行化。 这时候就需要掏出第四种方法，叫做 Automatic Differentiation：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/4-5.png"></p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/4-4.png"></p><p>其实思路非常简单，看伪代码就看的出来。这种方法就是通过反拓扑序去生成一个反向的计算图，因为是计算图所以不用保存任何中间变量；也因为是计算图，所以可以进行通用的并行化与代码优化，两全其美！ 接下来就是 Auto-diff 的具体实现，也就是 assignment 1。这次作业的难度不是太大，前面就是一些算子的简单实现，后面有两段重要的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> topo_order:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(node.op, PlaceholderOp):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    input_vals = [node_to_val_map[x] <span class="keyword">for</span> x <span class="keyword">in</span> node.inputs]</span><br><span class="line">    res = node.op.compute(node, input_vals)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(res, np.ndarray) == <span class="literal">False</span>:</span><br><span class="line">        res = np.array(res)</span><br><span class="line">    node_to_val_map[node] = res</span><br></pre></td></tr></table></figure><p>这段是前向传播的部分，记录每个节点计算出来的结果。前向传播需要正向拓扑序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> reverse_topo_order:</span><br><span class="line">    grad = sum_node_list(node_to_output_grads_list[node])</span><br><span class="line">    node_to_output_grad[node] = grad</span><br><span class="line">    input_grads = node.op.gradient(node, grad)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(node.inputs)):</span><br><span class="line">        node_to_output_grads_list[node.inputs[i]] = node_to_output_grads_list.get(node.inputs[i], [])</span><br><span class="line">        node_to_output_grads_list[node.inputs[i]].append(input_grads[i])</span><br></pre></td></tr></table></figure><p>这段是反向形成 Auto-diff 计算图的过程，跟伪代码很像。进一步解释一下：按照反拓扑序来遍历节点，计算到这个节点就代表着所有相关的梯度都计算完了。现在需要把相关的梯度都加起来，然后加起来的梯度作为这个节点向后面传播的梯度。整个过程很容易理解。</p><h2 id="lecture-5-gpu-programming">Lecture 5: GPU Programming</h2><p>这一讲涉及到的部分比较底层，虽然浙大本科的硬件三连质量非常高，但是对于 GPU 架构接触还是非常少的，又没有视频，只能尽力看一看了... 首先讲的是 CPU 的架构，很容易理解，CPU 跟内存有关的操作都很慢，所以才有各种指令预测、cache 优化算法之类的折磨着一代有一代的计算机学子：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/5-1.png"></p><p>而 GPU 则是给 CPU 加了一大堆计算资源，比普通的指令向量化更加强劲：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/5-2.png"></p><p>从这个图可以看出来，GPU 的寄存器数量非常大，所以他可以开很多线程去并行计算，但是从这个图也可以看出来，GPU 的 cache 小的可怜，所以 GPU 适用于那种轻内存读写、重计算的任务，也就是大量的并行计算任务。</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/5-3.png"></p><p>然后讲了 CUDA Programming Model，因为我完全不懂 CUDA 编程，所以后面的东西都是我瞎理解的，不一定对。 这个叫做 SIMT 的 Model 就是把几个 thread group 成一个 block，再把几个 block group 成一个 grid，block 可以以任何顺序在 GPU 上面调度。</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/5-3.5.png"></p><p>然后是个最简单的 cuda 程序——vector add。过程非常简单，跟操作系统里面查页表差不多，这里通过 block 下标和 thread 下标可以得到向量加法的下标，然后每个线程都执行一样的代码就可以了。</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/5-3.8.png"></p><p>后面讲了一个窗口 sum 的例子，因为他图画的不太好，所以有点难以理解，我尽力理解了一下：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/5-4.png"></p><p>最简单的实现方式是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIUS 3</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">windowSumNaiveKernel</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>* A, <span class="keyword">float</span>* B, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> out_index = blockDim.x * blockIdx.x + threadIdx.x;    </span><br><span class="line">    <span class="keyword">int</span> in_index = out_index + RADIUS;    </span><br><span class="line">    <span class="keyword">if</span> (out_index &lt; n) &#123;</span><br><span class="line">        <span class="keyword">float</span> sum = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -RADIUS; i &lt;= RADIUS; ++i) &#123;</span><br><span class="line">            sum += A[in_index + i];        </span><br><span class="line">        &#125;</span><br><span class="line">        B[out_index] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么说他图画的不太好，因为他的图跟代码的下标其实是对应不上的。B[0] 的结果应该是从 A[0] 到 A[6] 的和才对，这样下标就和代码完全对应上了。 这个实现非常简单，所以有很大的优化空间。其中最脑残的地方就是每个线程都读了 7 次 A，这样对 GPU 这种小 cache 来说是非常残忍的。</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/5-5.png"></p><p>所以一个非常简单的优化就是从一个线程读 7 次 A，变成一个 block (假设有四个线程) 读 9 次 A。</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/5-6.png"></p><p>那么下面的实现就很好理解了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">windowSumKernel</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>* A, <span class="keyword">float</span>* B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    __shared__ <span class="keyword">float</span> temp[THREADS_PER_BLOCK + <span class="number">2</span> * RADIUS];</span><br><span class="line">    <span class="keyword">int</span> out_index = blockDim.x * blockIdx.x + threadIdx.x;</span><br><span class="line">    <span class="keyword">int</span> in_index = out_index + RADIUS;</span><br><span class="line">    <span class="keyword">int</span> local_index = threadIdx.x + RADIUS;</span><br><span class="line">    <span class="keyword">if</span> (out_index &lt; n) &#123;</span><br><span class="line">        temp[local_index] = A[in_index];</span><br><span class="line">        <span class="keyword">if</span> (threadIdx.x &lt; RADIUS) &#123;</span><br><span class="line">            temp[local_index - RADIUS] = A[in_index - RADIUS];</span><br><span class="line">            temp[local_index + THREADS_PER_BLOCK] = A[in_index+THREADS_PER_BLOCK];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">        <span class="keyword">float</span> sum = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -RADIUS; i &lt;= RADIUS; ++i) &#123;</span><br><span class="line">            sum += temp[local_index + i];</span><br><span class="line">        &#125;        </span><br><span class="line">        B[out_index] = sum;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比较奥妙的地方是 if (threadIdx.x &lt; RADIUS) 这个语法块，其实也不难理解，就是把两边的 RADIUS 部分充满。最后是一个简单的矩阵乘法程序：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/5-7.png"></p><h2 id="lecture-6-optimize-for-hardware-backends">Lecture 6: Optimize for Hardware Backends</h2><p>这一讲处于计算图和硬件之间。 首先讲了一些体系结构的基本知识，比如多级 cache 之类的，然后讲了矩阵乘法的 cache 优化，非常基础。 最简单的矩阵乘法如下图所示：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/6-1.png"></p><p>像上面这样直接做矩阵乘法，其实对 cache 的利用率并不高，更好的方式是把矩阵分成很多个小块：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/6-2.png"></p><p>分块的方法可以缩小从下级 cache 到寄存器的 cost，有人想那我直接把 v1、v2 高的大一点，这样不就可以优化更多了吗？ 但是通常来说，寄存器非常小，很难存下一整列或者一整行，所幸 CPU 的 cache 通常比较大，也许可以存下：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/6-3.png"></p><p>把对寄存器的优化和 L1 cache 的优化相结合，就得到了下面这种比较复杂的优化方式：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/6-4.png"></p><p>对于 CPU 来说，代码优化可能集中于 Reuse memory 上面，而 GPU 的优化则是集中于 Reuse among threads 上。（这段其实不太懂，我理解就是跟前一讲的那个 window sum 一样，优化复用不同线程的内存）</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/6-5.png"></p><p>对于计算图的代码优化，其实套路千变万化：</p><p><img src="/2019/11/08/cse-599w-systems-for-ml-1-6/6-6.png"></p><p>为了解决这样的优化问题，我们就需要本门课的核心内容——TVM 了！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://dlsys.cs.washington.edu/&quot;&gt;课程网站&lt;/a&gt; 在头条 AML 实习的时候就觉得这个 AI system 方向非常有趣，但是苦于实验室不是搞这一套的，自己拖延症也非常严重，所以一直在入门的边缘徘徊。但是在今天——研一秋学期考试周的前一周，我决定开始学习 AI system 方向最著名的必学课程，Tianqi Chen 在 UW 开设的 CSE599W。 这个课程其实资料并不是很完善，只有 github 上面的几个 repo 和课程网站上面的 slide，缺乏讲课的视频资源。而且在开始学习之前就听说很多地方 slide 写的非常简陋，只能通过 tvm 和 tinyflow 代码慢慢学习。我在学习之前也找了一些 blog 资源，开个坑，希望可以努力坚持下来！ 本人的作业也开源到 &lt;a href=&quot;https://github.com/wyc-ruiker/CSE-599W-2018&quot;&gt;github&lt;/a&gt; 上面了，希望大家多多指导。&lt;/p&gt;</summary>
    
    
    
    <category term="system" scheme="https://reku1997.gitee.io/categories/system/"/>
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/system/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="learning" scheme="https://reku1997.gitee.io/tags/learning/"/>
    
    <category term="system" scheme="https://reku1997.gitee.io/tags/system/"/>
    
    <category term="课程笔记" scheme="https://reku1997.gitee.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>从 AdaBoost 到 GBDT</title>
    <link href="https://reku1997.gitee.io/2019/07/26/adaboost/"/>
    <id>https://reku1997.gitee.io/2019/07/26/adaboost/</id>
    <published>2019-07-26T08:07:10.000Z</published>
    <updated>2021-12-16T11:24:07.607Z</updated>
    
    <content type="html"><![CDATA[<p>集成学习顾名思义，就是把一堆垃圾方法集成起来变成一个牛逼的方法。集成学习主要分为两种思路：Bagging 和 Boosting。Bagging 的话就是一堆独立的垃圾方法，比如随机森林，就是通过不同的采样和不同的特征抽取方法产生一堆独立的决策树，然后把他们的决策进行投票。而 Boosting 则是通过一个垃圾方法来产生下一个垃圾方法，最知名的方法就是 AdaBoost 了。</p><span id="more"></span><h2 id="看上去傻傻的-adaboost">看上去傻傻的 AdaBoost</h2><p>对于普通的集成学习来说，其实最后的结果就是不同方法的线性组合，以二分类问题（1，-1）为例，最后的结果在数学上可以表示为： <span class="math display">\[G=sign(\sum_{t=1}^T\alpha_t g_t(x_n))\]</span></p><p>上面的 <span class="math inline">\(g_t\)</span> 就代表不同的学习方法，而 <span class="math inline">\(\alpha_t\)</span> 代表着每个学习方法的权重。 在 AdaBoost 中，最关键的一点就是对于错误函数的修改。AdaBoost 使用的是带权重的错误函数，<span class="math inline">\(u_n\)</span> 代表着每个样本点犯错误的权重： <span class="math display">\[E_{in}^u(h)=\frac1N\sum_{n=1}^N u_n\cdot err(y_n,h(x_n))\]</span></p><p>我们就是要使用不同的 <span class="math inline">\(u_n\)</span> 来的得到不同的方法 <span class="math inline">\(g_t\)</span>。显然，全都差不多的 <span class="math inline">\(g_t\)</span> 最后集成学习出来的效果肯定很垃圾。从参数上面思考可以看出，模型 <span class="math inline">\(g_t\)</span> 是通过参数 <span class="math inline">\(u_n^t\)</span> 生成的，而模型 <span class="math inline">\(g_{t+1}\)</span> 则是通过参数 <span class="math inline">\(u_n^{t+1}\)</span> 来生成的。我们想让 <span class="math inline">\(g_t\)</span> 和 <span class="math inline">\(g_{t+1}\)</span> 产生足够大的差距，其实就是让 <span class="math inline">\(u_n^{t+1}\)</span> 对应的 error 在 <span class="math inline">\(g_t\)</span> 上表现很差就好了。 什么叫表现的差呢？对于分类预测来说，最差的结果其实就是扔硬币，也就是说达到百分之 <span class="math inline">\(50\)</span> 的错误率，这个结果已经是最差的了。我们就是要通过构造 <span class="math inline">\(u_n^{t+1}\)</span> 使得 <span class="math inline">\(g_t\)</span> 在这个 error 上的错误率接近 <span class="math inline">\(0.5\)</span>。</p><p>AdaBoost 的做法很简单，如果 <span class="math inline">\(g_t\)</span> 的错误率为 <span class="math inline">\(\epsilon_t\)</span> 的话，那么构造一个尺度因子： <span class="math display">\[\diamond t=\sqrt{\frac{1-\epsilon_t}{\epsilon_t}}\]</span></p><p>对于正确的 <span class="math inline">\(u_n^t\)</span> 可以乘上 <span class="math inline">\(\diamond t\)</span>，对于错误的 <span class="math inline">\(u_n^t\)</span>，可以除上 <span class="math inline">\(\diamond t\)</span>。这样就会使得正确的和错误的参数 <span class="math inline">\(u_{n+1}^t\)</span> 达到平衡，从而达到放大错误、缩小正确的目的，使得 <span class="math inline">\(g_t\)</span> 在新 error 上面的错误率等于 <span class="math inline">\(0.5\)</span>。 现在有了生成每个 <span class="math inline">\(g_t\)</span> 的方法，那每个方法的参数 <span class="math inline">\(\alpha_t\)</span> 应该是什么呢？一个直观的想法是：生成完方法之后，再对这些方法进行线性组合的优化，然后来求出 <span class="math inline">\(\alpha_t\)</span>。这样固然是可以的，但是其实我们可以通过数学推导，来直接算出这个 <span class="math inline">\(\alpha_t\)</span>。这里先下结论，一会儿再进行数学推导： <span class="math display">\[\alpha_t=ln(\diamond t)\]</span></p><p>最简单的一种 AdaBoost 方法叫做 AdaBoost-Stump。在 AdaBoost-Stump 中，每个小方法都只能在某个维度上面画直线来对训练集进行分类。但就是这样简单的方法，可以通过 Boost 组合的方式达到非常好的效果，这就是 AdaBoost 的神奇之处。 现在我们想利用 AdaBoost 把决策树来组合起来。但是问题来了，首先是 error 函数如何参与决策树的分支操作，这个参与起来会比较麻烦。比较简单的做法是直接对决策树屏蔽了 <span class="math inline">\(u_n\)</span> 参数。然后通过 <span class="math inline">\(u_n\)</span> 参数来对训练集进行采样，来达到不同 error 函数的效果。这样决策树就是原来的决策树，不需要进行任何的修改。 另一个问题就是，很多决策树都是直接把叶子剖分到单个结点或者单个类别。这样的做法必然会导致这个决策树在测试集上面的错误率 <span class="math inline">\(\epsilon_t\)</span> 等于 <span class="math inline">\(0\)</span>。这样我们就没有办法通过 <span class="math inline">\(\diamond t\)</span> 来产生下一个垃圾方法了。当然解决这个问题的方法也很简单，对决策树进行剪枝和采样数据不全部采样都是可以尝试的做法。这个方法叫做 AdaBoost-DTree。值得注意的一点是：如果我们的决策树的高度限制为 <span class="math inline">\(1\)</span>，也就是说只能做一次划分，那么这个方法就跟 AdaBoost-Stump 没有任何区别啦。也就是说 AdaBoost-Stump 是 AdaBoost-DTree 的退化。</p><h2 id="奥妙重重的-adaboost">奥妙重重的 AdaBoost</h2><p>还记得上面的 <span class="math inline">\(\alpha_t\)</span> 吗？下面就是通过推导 <span class="math inline">\(\alpha_t\)</span> 来发现 AdaBoost 的奥妙之处了。当然过程中其实涉及到一些高深的数学知识，但是因为我都不会，所以很多地方可能会讲的很“民科”。 上面说过 <span class="math inline">\(u_n^{t+1}\)</span> 的求法：对于正确的 <span class="math inline">\(u_n^t\)</span> 可以乘上 <span class="math inline">\(\diamond t\)</span>，对于错误的 <span class="math inline">\(u_n^t\)</span>，可以除上 <span class="math inline">\(\diamond t\)</span>。通过数学式子其实可以将他们归纳成一个规律： <span class="math display">\[u_n^{(t+1)}=u_n^{(t)}\cdot \diamond_t^{-y_ng_t(x_n)}=u_n^{(t)}\cdot exp(-y_n\alpha_tg_t(x_n))\]</span></p><p>如果初始值 <span class="math inline">\(u_n^{(1)}=\frac1N\)</span> 的话，就有： <span class="math display">\[u_n^{(T+1)}=u_n^{(1)}\cdot \prod_{t=1}^Texp(-y_n\alpha_tg_t(x_n))=\frac1N\cdot exp(-y_n\sum_{t=1}^T\alpha_tg_t(x_n))\]</span></p><p>通过上面的式子可以发现一个很显然的事情：<span class="math inline">\(u_n^{(T+1)}\)</span> 与 <span class="math inline">\(exp(-y_n\sum_{t=1}^T\alpha_tg_t(x_n))\)</span> 成正比。 将 <span class="math inline">\(\sum_{t=1}^T\alpha_tg_t(x_n)\)</span> 从另外一个角度来看，可以发现这个其实是一个对 <span class="math inline">\(x_n\)</span> 特征转换的线性组合，跟 SVM 中的那个完全一致。其实这个式子就是没有进行正则化的分界距离，跟 <span class="math inline">\(y_n\)</span> 相乘的话，可以感性的理解成跟 SVM 一样，这个距离越大越好。 使得 <span class="math inline">\(y_n\sum_{t=1}^T\alpha_tg_t(x_n)\)</span> 越大越好，那么显然 <span class="math inline">\(exp(-y_n\sum_{t=1}^T\alpha_tg_t(x_n))\)</span> 越小越好，于是 <span class="math inline">\(u_n^{(T+1)}\)</span> 也就越小越好。 我们的目标就变成了最小化： <span class="math display">\[\sum_{n=1}^Nu_n^{(T+1)}=\frac1N\sum_{n=1}^Nexp(-y_n\sum_{t=1}^T\alpha_tg_t(x_n))\]</span></p><p>因为 <span class="math inline">\(\sum_{t=1}^T\alpha_tg_t(x_n)\)</span> 是我们的预测项，所以这个最小化其实也是另一种错误函数，而且这个错误函数显然是 0/1 error 的上界，这个错误函数一般叫做 <span class="math inline">\(\hat{err}_{ADA}\)</span>。 有个优化函数，下面的问题就是如何求出这个优化函数 <span class="math inline">\(\sum_{n=1}^Nu_n^{(T+1)}\)</span> 的最小值了。 思考梯度下降的过程，我们通过泰勒展开发现梯度的反方向是要求下降的最好方向，当然梯度下降的方向是一个向量。但是我们这里的“梯度”其实是一个函数，函数跟向量其实并没有多大的区别，只是一个下标是连续的一个下标是离散的（因为数学不好，只能这么理解了）。 接下来对要最小化的式子进行推导： <span class="math display">\[\frac1N\sum_{n=1}^Nexp(-y_n(\sum_{t=1}^T\alpha_tg_t(x_n)+\eta h(x_n)))=\sum_{n=1}^Nu_n^Texp(-y_n\eta h(x_n))\]</span></p><p>对这个式子进行最简单的一阶泰勒展开可以得到：<span class="math display">\[\sum_{n=1}^Nu_n^Texp(-y_n\eta h(x_n))=\sum_{n=1}^Nu_n^t(1-y_n\eta h(x_n))=\sum_{n=1}^Nu_n^t-\eta\sum_{n=1}^Nu_n^ty_nh(x_n)\]</span></p><p>先忽略掉步长 <span class="math inline">\(\eta\)</span>，我们的目标就变成了找到一个好的 <span class="math inline">\(h(x_n)\)</span> 来最小化 <span class="math inline">\(\sum_{n=1}^Nu_n^{(t)}(-y_nh(x_n))\)</span>。 对于二分类问题，<span class="math inline">\(-y_nh(x_n)\)</span> 的值要么是 <span class="math inline">\(-1\)</span> 要么是 <span class="math inline">\(1\)</span>。当 <span class="math inline">\(y_n = h(x_n)\)</span> 时，<span class="math inline">\(\sum_{n=1}^Nu_n^{(t)}(-y_nh(x_n)) = -\sum_{n=1}^Nu_n^{(t)}\)</span>，当 <span class="math inline">\(y_n \neq h(x_n)\)</span> 时，<span class="math inline">\(\sum_{n=1}^Nu_n^{(t)}(-y_nh(x_n)) = \sum_{n=1}^Nu_n^{(t)}\)</span>。将这个结果稍微平移并且统一一下，可以发现一件神奇的事情：<span class="math inline">\(\sum_{n=1}^Nu_n^{(t)}(-y_nh(x_n)) = -\sum_{n=1}^Nu_n^{(t)}+2E_{in}^{u_n^{(t)}}\cdot N\)</span>。 太有趣了。让原来的 <span class="math inline">\(\sum_{n=1}^Nu_n^{(t)}(-y_nh(x_n))\)</span> 竟然最优的 <span class="math inline">\(h(x_n)\)</span> 就是让 <span class="math inline">\(E_{in}^{u_n^{(t)}}\)</span> 最小的 <span class="math inline">\(h(x_n)\)</span>，也就是我们的 AdaBoost 过程中求出的 <span class="math inline">\(g_t\)</span>！ 在之前梯度下降的时候，我们选择的是自己随便设置一个步长，但是在 AdaBoost 里面，因为我们要组合各个方法以达到最好的效果，所以这个步长其实就是最后预测式中的 <span class="math inline">\(\alpha_t\)</span>。这个步长也就是在最佳方向上的最大步进长度，先把要求最佳步长的表达式写下来： <span class="math display">\[\check{E}_{ADA}=\sum_{n=1}^Nu_n^{(t)}exp(-y_n\eta g_t(x_n))\]</span></p><p>有两种情况需要我们考虑，分别是预测正确：<span class="math inline">\(u_n^{(t)}exp(-\eta)\)</span>，和预测错误：<span class="math inline">\(u_n^{(t)}exp(+\eta)\)</span>。 之前我们将错误率以符号 <span class="math inline">\(\epsilon_t\)</span> 来表示，经过简单推导统一，可以得到： <span class="math display">\[\check{E}_{ADA}=(\sum_{n=1}^Nu_n^{(t)})\cdot ((1-\epsilon_t)exp(-\eta)+\epsilon_t\ exp(+\eta))\]</span></p><p>求导，<span class="math inline">\(\frac{\partial \check{E}_{ADA}}{\partial \eta}=0\)</span> 得到： <span class="math display">\[\eta_t=ln\sqrt{\frac{1-\epsilon_t}{\epsilon_t}}=\alpha_t\]</span></p><p>这就是 <span class="math inline">\(\alpha_t = ln\sqrt{\frac{1-\epsilon_t}{\epsilon_t}}\)</span> 的原因啦！</p><h2 id="从-adaboost-到-gradient-boosting">从 AdaBoost 到 Gradient Boosting</h2><p>总结一下之前 AdaBoost 的求解过程，其实就是去优化以下式子： <span class="math display">\[min_{\eta}min_h\frac1N\sum_{n=1}^Nexp(-y_n(\sum_{t=1}^T\alpha_tg_t(x_n)+\eta h(x_n)))\]</span></p><p>之前说了，这个 <span class="math inline">\(exp\)</span> 函数其实只是错误函数的一种形式，我们也可以换成其他类型的 error 函数，比如这样： <span class="math display">\[min_{\eta}min_h\frac1N\sum_{n=1}^Nerr(\sum_{t=1}^T\alpha_tg_t(x_n)+\eta h(x_n), y_n)\]</span></p><p>这个公式就是一种通用的 Gradient Boosting 啦！ 接下来，我们就使用普通的 regression 错误（<span class="math inline">\(err(s,y)=(s-y)^2\)</span>）来看看 regression 情况下的 Gradient Boosting 是怎么回事吧~ 我们将 <span class="math inline">\(\sum_{t=1}^T\alpha_tg_t(x_n)\)</span> 看做 <span class="math inline">\(s_n\)</span>，那么原式通过泰勒展开之后就等于： <span class="math display">\[min_h\frac1N\sum_{n=1}^Nerr(s_n,y_n)+\frac1N\sum_{n=1}^N\eta h(x_n)\frac{\partial err(s,y_n)}{\partial s}\]</span></p><p>其中的一阶导数<span class="math inline">\(\frac{\partial err(s,y_n)}{\partial s}=2(s_n-y_n)\)</span>。 去除一堆常数项和常数因子，其实我们只需要最小化<span class="math inline">\(h(x_n)\cdot 2(s_n-y_n)\)</span>就好了。所以只要令<span class="math inline">\(h(x_n)\)</span>是梯度<span class="math inline">\(2(s_n-y_n)\)</span>的反方向就好了，但是这个反方向究竟要取多大呢？回想一下我们之前的梯度下降，其实梯度只代表一个方向，多大并没有什么关系。为了防止这个梯度取到无穷大，我们需要对梯度的大小进行一下限制。参考之前的正则化思路，我们也可以通过加上一个惩罚项<span class="math inline">\(h^2(x_n)\)</span>来得到新的优化式子，经过添加常数进行整理，可以得到我们最后关心的优化式子： <span class="math display">\[min\sum_{n=1}^N((h(x_n)-(y_n-s_n))^2)\]</span></p><p>也就是说，我们利用我们的基础 regression 方法使得 <span class="math inline">\(h(x_n)\)</span> 更加接近 <span class="math inline">\(y_n-s_n\)</span> 就可以了。简单的来说就是对所有 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\((x_n, y_n-s_n)\)</span> 做 regression，得到的回归方程就是我们要求的 <span class="math inline">\(g_t(x_n)\)</span> 啦！ 其中一个很重要的概念就是 <span class="math inline">\(y_n-s_n\)</span>，很多博客会把这个东西叫做残差。也就是这些残差来决定 <span class="math inline">\(g_t\)</span>。 现在需要求出步长 <span class="math inline">\(\eta\)</span>。这个步骤非常简单，把我们之前求出来的 <span class="math inline">\(g_t\)</span> 代回到原来的优化式子中们可以得到： <span class="math display">\[min_{\eta}\frac1N\sum_{n=1}^N(s_n+\eta g_t(x_n)-y_n)^2 = \frac1N\sum_{n=1}^N((y_n-s_n)-\eta g_t(x_n))^2\]</span></p><p>可以发现，这里又是对残差进行拟合。不过这个拟合只有一个变量，非常简单，只需要简单求个导数就可以得到我们需要的 <span class="math inline">\(\eta\)</span> 啦！ 这个 Gradient Boosting 最出名的利用方法就是我们标题中提到的大名鼎鼎的 Gradient Boosted Decision Tree(GBDT) 啦！不过我们整个推导过程中好像并没有用过决策树啊？这个决策树要在哪里使用呢？ 很简单，就是我们通过决策树来做每一步的 regression 就好啦！有一个细节是，因为我们在求第一棵决策树的时候并没有残差这个东西，所以直接对各个 <span class="math inline">\((x_n, y_n)\)</span> 做拟合就好了，从第二棵决策树开始对残差做拟合。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;集成学习顾名思义，就是把一堆垃圾方法集成起来变成一个牛逼的方法。集成学习主要分为两种思路：Bagging 和 Boosting。Bagging 的话就是一堆独立的垃圾方法，比如随机森林，就是通过不同的采样和不同的特征抽取方法产生一堆独立的决策树，然后把他们的决策进行投票。而 Boosting 则是通过一个垃圾方法来产生下一个垃圾方法，最知名的方法就是 AdaBoost 了。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>支持向量机的清晰推导</title>
    <link href="https://reku1997.gitee.io/2019/07/06/svm/"/>
    <id>https://reku1997.gitee.io/2019/07/06/svm/</id>
    <published>2019-07-06T06:12:16.000Z</published>
    <updated>2021-12-16T11:32:34.327Z</updated>
    
    <content type="html"><![CDATA[<p>其实是标题党啦... SVM 推导作为最臭名昭著的机器学习面试题，其实我在去年的这个时候准备头条实习面试的期间就已经“背诵”过了，但完全没有理解自己推导的是个什么东西。最近看台大的《机器学习技法》的课程视频，感觉这个 SVM 推导过程讲的非常清晰。最关键的是每一步的 motivation 都讲的非常清楚，正好博客也好久好久好久没有更新了，这里简单重复一下，以证明自己学会了 SVM 的推导吧~</p><span id="more"></span><h2 id="从线性分割说起"><strong>从线性分割说起</strong></h2><p>在《机器学习基石》课程中讲了一个基于迭代的简单线性分类算法 PLA，但是对一个二分类的数据集，合法的分类线普遍是无数条。对于这无数条线我们应该选择哪条线作为我们最终分类的结果才比较好呢？</p><p><img src="/2019/07/06/svm/a.png"></p><p>从上图来看，显然最右边这一列是比较合理的分割方法。也就说，离分类线的最近的点要尽可能的远，这样对各种噪音误差的兼容性是最好的。 用数学的定义来说就是： <span class="math display">\[max_{w}min_{n=1...N}distance(x_n, w)\]</span></p><p>对于每个点来说都必须存在<span class="math inline">\(y_nw^Tx_n&gt;0\)</span>（如果一定要每个点都没有分割错误的话）。 在计算距离的时候，bias 显然是不应该参与进来的，所以需要把 bias 从矩阵中拆出来，变成<span class="math inline">\(h(x)=sign(w^Tx+b)\)</span>的形式，距离就从<span class="math inline">\(distance(x,w)\)</span>变成了<span class="math inline">\(distance(x,b,w)\)</span>。 下面要计算点<span class="math inline">\(x\)</span>到超平面<span class="math inline">\(w^Tx+b\)</span>的距离，这个就是一个简单的投影，得到 <span class="math display">\[distance(x,b,w)=\frac{|w^Tx+b|}{||w||}\]</span></p><p>因为上面有对于每个点来说都必须存在<span class="math inline">\(y_n(w^Tx_n+b)&gt;0\)</span>的条件，所以分子里面这个麻烦的绝对值式子可以直接用<span class="math inline">\(y_n(w^Tx_n+b)\)</span>来代替（反正<span class="math inline">\(y_n\)</span>要么是<span class="math inline">\(1\)</span>要么是<span class="math inline">\(-1\)</span>，不会对结果有任何影响），所以得到以下式子： <span class="math display">\[distance(x,b,w)=\frac{y_n(w^Tx_n+b)}{||w||}\]</span></p><p>又因为<span class="math inline">\(w^Tx_n+b\)</span>这个东西是可以加常数放缩的，也就是说<span class="math inline">\(w^Tx_n+b\)</span>跟<span class="math inline">\(3w^Tx_n+3b\)</span>所代表的平面是完全一致的，所以我们完全可以通过放缩使得最小的平面求出来的值等于<span class="math inline">\(1\)</span>，这样的好处是，最小的 distance 一定是 <span class="math inline">\(\frac{1}{||w||}\)</span>。这样做我们要求的数学式子就变为： <span class="math display">\[max_{w}\frac{1}{||w||}min_{n=1...N}y_n(w^Tx_n+b)=1\]</span></p><p>但是接下来有个奇怪的问题，如果我们限制的条件是所有的<span class="math inline">\(y_n(w^Tx_n+b)\ge 1\)</span>，那一定会有一个<span class="math inline">\(w\)</span>使得<span class="math inline">\(y_n(w^Tx_n+b)=1\)</span>吗？ 这个证明其实很简单，如果最优的<span class="math inline">\(w\)</span>使得<span class="math inline">\(y_n(w^Tx_n+b)=1.126\)</span>，那么我们只要取<span class="math inline">\((b/1.126, w/1.126)\)</span>这样一组解，就会比之前的<span class="math inline">\(w\)</span>更优了。 现在优化目标已经很明显了，为了之后陈述方便，我们将最大化<span class="math inline">\(\frac{1}{||w||}\)</span>变成最小化<span class="math inline">\(w^Tw\)</span>。为了后续的推导方便，加了一个<span class="math inline">\(\frac{1}{2}\)</span>的放缩。于是我们的优化函数就变成了下面这样： <span class="math display">\[min_{w}\frac{1}{2}w^Tw\]</span><span class="math display">\[min_{n=1...N}y_n(w^Tx_n+b)\ge 1\]</span></p><p>现在有了优化函数，如何求解呢？可以很简单的发现，这是一个非常经典的二次规划问题！给出一堆<span class="math inline">\(w\)</span>的限制，求解一个<span class="math inline">\(w\)</span>二次项的最优解！ 对于非线性的情况，我们只要把线性的映射到非线性情况就行了，非常的 easy，真是太爽了！</p><h2 id="为什么我们需要对偶问题"><strong>为什么我们需要对偶问题</strong></h2><p>不是都爽了吗？还要搞啥呢？ 真的爽吗？我们想一下，线性的情况确实蛮爽的，但是非线性的情况，当我们要将低维的特征映射的高维的时候，将<span class="math inline">\(x_n\)</span>映射到<span class="math inline">\(z_n\)</span>，这个代价是非常巨大的。比如一个<span class="math inline">\(x_n=(x1, x2)\)</span>特征，映射到二维就需要<span class="math inline">\(z_n=(1, x1, x2, x1^2, x2^2, x1x2)\)</span>这么多东西，更高的维度需要的代价会更大。 为了解决这个问题，我们首先需要了解一个叫做 Lagrange Mulitipliers 的东西。这个东西在正则化的时候，我们其实已经了解过了，大致是这个形式： <span class="math display">\[min_wE_{in}(w), w^Tw\le C \cong min_w(E_{aug}(w)=E_{in}(w)+\frac{\lambda}{N}w^Tw)\]</span></p><p>既然<span class="math inline">\(w^Tw\le C\)</span>我们可以通过在后面加一个<span class="math inline">\(\frac{\lambda}{N}w^Tw\)</span>来获得等价问题，那么<span class="math inline">\(y_n(w^Tz_n+b)\ge 1\)</span>这个条件我们显然也可以如法炮制，大致是这个形式： <span class="math display">\[L(b,w,a)=\frac{1}{2}w^Tw+\sum_{n=1}^N\alpha_n(1-y_n(w^Tz_n+b))\]</span><span class="math display">\[\min_{b,w}(max_{\alpha_n\ge 0}L(b,w,\alpha))\]</span>我们保证<span class="math inline">\(\alpha_n\ge 0\)</span>这样的条件，这样就可以使得所有<span class="math inline">\(1-y_n(w^Tz_n+b)\)</span>都符合不超过<span class="math inline">\(0\)</span>的要求。因为如果有一个<span class="math inline">\(1-y_n(w^Tz_n+b)ge 0\)</span>，那就可以让对应的<span class="math inline">\(\alpha_n\)</span>为无穷，优化的 max 就是无穷大了。 但是这个东西我们还是不会优化，这时候就需要引入一个叫做拉格朗日对偶问题的东西，这个东西通过一系列的证明，表示在我们这个优化形式下，这两个问题是完全等价的： <span class="math display">\[min_{b,w}(max_{a_n\ge 0}L(b,w,\alpha))\cong max_{a_n\ge0}(min_{b,w}L(b,w,\alpha))\]</span></p><p>展开来写的话就是： <span class="math display">\[max_{a_n\ge0}(min_{b,w}\frac{1}{2}w^Tw+\sum_{n=1}^N\alpha_n(1-y_n(w^Tz_n+b)))\]</span></p><p>下面开始魔法时刻~</p><p>如果里面的那个最小值优化是一个最值的话，那么对于每一个参数的偏导都应该是<span class="math inline">\(0\)</span>。基于这一点，我们就可以做一些有趣的事情了。 首先对里面的<span class="math inline">\(L(b,w,\alpha)\)</span>求<span class="math inline">\(b\)</span>的偏导，可以得到如下式子： <span class="math display">\[\frac{\partial L(b,w,\alpha)}{\partial b}=-\sum_{n=1}^N\alpha_ny_n=0\]</span></p><p>这个结论其实就有点神奇了，但是更神奇的地方在于，我们把<span class="math inline">\(L(b,w,\alpha)\)</span>展开，发现<span class="math inline">\(b\)</span>的系数恰好就是这个<span class="math inline">\(-\sum_{n=1}^N\alpha_ny_n\)</span>！也就说<span class="math inline">\(b\)</span>这一项直接就可以消掉！</p><p>继续我们的魔法之旅，下面对<span class="math inline">\(L(b,w,\alpha)\)</span>求<span class="math inline">\(w_i\)</span>的偏导： <span class="math display">\[\frac{\partial L(b,w,\alpha)}{\partial w_i}=w_i-\sum_{n=1}^N\alpha_ny_nz_{n,i}=0\]</span></p><p>这样就得到了一个有趣的结论，<span class="math inline">\(w=\sum_{n=1}^N\alpha_ny_nz_n\)</span>。 将这个结论带入回原来的式子，可以得到： <span class="math display">\[max(\frac{1}{2}||\sum_{n=1}^N\alpha_ny_nz_n||+\sum_{n=1}^N\alpha_n)\\ a_n\ge0, \sum_{n=1}^N\alpha_ny_n=0, w=\sum_{n=1}^N\alpha_ny_nz_n\]</span></p><p>所谓的 KKT 条件，其实也就是上面式子的几个条件了，还有一个原来定义中的条件<span class="math inline">\(y_n(w^Tx_n+b)\ge1\)</span>，当然还有一个最有趣的 KKT 条件就是<span class="math inline">\(\alpha_n(1-y_n(w^Tz_n+b))=0\)</span>，因为在优化的过程中，我们要求最后结果的最大值，而两个非负数相乘最后想要结果最大的话，必须其中一个为<span class="math inline">\(0\)</span>，那么上面这个条件就必须成立。 通过取负数将优化最大值变成优化最小值，然后展开可以得到： <span class="math display">\[min_{\alpha}\frac{1}{2}\sum_{n=1}^N\sum_{m=1}^N\alpha_n\alpha_my_ny_mz_n^Tz_m-\sum_{n=1}^N\alpha_n\\ a_n\ge0, \sum_{n=1}^N\alpha_ny_n=0\]</span></p><p>诶，这个东西的形式是不是有点眼熟？没错，就是二次规划，太爽了，对偶问题我们现在也会求解了！ 求解出<span class="math inline">\(\alpha\)</span>之后，就可以通过<span class="math inline">\(w=\sum_{n=1}^N\alpha_ny_nz_n\)</span>求出<span class="math inline">\(w\)</span>。那我们的 bias 呢？还记得<span class="math inline">\(\alpha_n(1-y_n(w^Tz_n+b))=0\)</span>这个 KKT 条件吗？在<span class="math inline">\(\alpha_n&gt;0\)</span>的时候，我们就可以求出对应的 bias 了，而那些<span class="math inline">\(\alpha_n&gt;0\)</span>所对应的<span class="math inline">\(n\)</span>，其实就是所谓的支持向量！ 当然了，这个时候聪明的读者就会发现，你这个不还是有一个<span class="math inline">\(z_n^Tz_m\)</span>吗？复杂度并没有降低啊？</p><h2 id="久等了核方法"><strong>久等了，核方法！</strong></h2><p>核方法其实跟 SVM 的推导并没有什么直接关系，但是在 SVM 的使用中却是大放异彩的。 所谓的核方法，其实就是一些神奇的<span class="math inline">\(z_n^Tz_m\)</span>求法，这些核方法可以完成很好的空间变换功能，甚至将原来的特征空间变换到无限维，正是核方法的出现，才使得 SVM 在某一个历史时期“一统江湖”的。 比如我们有一个垃圾特征空间变换，将<span class="math inline">\(x_n=(x_1, x_2, x_3, ..., x_d)\)</span>变换到<span class="math inline">\(\phi_n=(1, x_1, x_2, ..., x_d, x_1x_2, ..., x_1x_d, x_2x_1, x_2^2, ..., x_2x_d, ..., x_d^2)\)</span>。 现在我们想知道<span class="math inline">\(\phi_n(x)^T\phi_n(x^*)\)</span>，直接乘起来的话复杂度是<span class="math inline">\(O(d^2)\)</span>。我们通过观察式子，进行一定程度的优化可以发现<span class="math inline">\(\phi_n(x)^T\phi_n(x)=1+x^Tx^*+(x^Tx^*)(x^Tx^*)\)</span>。这样复杂度就是<span class="math inline">\(O(d)\)</span>了，是不是很棒？ 当然了，还有很多例如 RBF 之类的比较复杂的核方法，这里就不加赘述了，在实际应用中通常将<span class="math inline">\(z_n^Tz_m\)</span>换成<span class="math inline">\(K(x_n, x_m)\)</span>就代表核方法啦。</p><h2 id="虚假的-svm-和真正的-svm"><strong>虚假的 SVM 和真正的 SVM</strong></h2><p>其实上面讲的 SVM 跟实际使用的 SVM 并不完全一致，主要问题出现在大前提上，就是<span class="math inline">\(y_n(w^Tx_n+b)\ge1\)</span>这个定义。这个定义要求我们每个点都不能分割错误，过于严格，因为有一些噪音的结果是不需要考虑的。我们的 SVM 需要容忍一些分割错误。 我们将原来的 SVM 扩展一下，形式如下： <span class="math display">\[min_{b,w,\xi}\frac{1}{2}w^Tw+C\sum_{n=1}^N\xi_n\\ y_n(w^Tz_n+b)\ge1-\xi_n, \xi_n\ge0\]</span></p><p>其中参数<span class="math inline">\(C\)</span>就是用来 trade-off 容错率和分割线的鲁棒性的，参数<span class="math inline">\(\xi_n\)</span>就是表示这个点到底犯了多少错。 用 Lagrange Mulitipliers 重写这个优化式子，形式是这样： <span class="math display">\[L(b,w,\xi,\alpha,\beta)=\frac{1}{2}w^Tw+C\sum_{n=1}^N\xi_n+\sum_{n=1}^N\alpha_n(1-\xi_n-y_n(w^Tz_n+b))+\sum_{n=1}^N\beta_n(-\xi_n)\]</span></p><p><span class="math display">\[max_{\alpha_n\ge0, \beta_n\ge0}(min_{b,w,\xi}L(b,w,\xi,\alpha,\beta))\]</span></p><p>跟原来一样，通过求<span class="math inline">\(\xi_n\)</span>的偏导可以发现： <span class="math display">\[\frac{\partial L(b,w,\xi,\alpha,\beta)}{\partial \xi_n}=C-\alpha_n-\beta_n=0\]</span> 跟之前的 bias 一样，我们将式子展开之后，发现<span class="math inline">\(\xi_n\)</span>的系数就是上面这个等于<span class="math inline">\(0\)</span>的式子，所以<span class="math inline">\(\xi_n\)</span>这一项就没了。但是需要多一个<span class="math inline">\(0\le\alpha_n\le C\)</span>的条件。很神奇，这一项没了之后，我们的式子又开始变得眼熟起来： <span class="math display">\[max_{0\le\alpha_n\le C}(min_{b,w}\frac{1}{2}w^Tw+\sum_{n=1}^N\alpha_n(1-y_n(w^Tz_n+b)))\]</span></p><p>后面的事情就很显而易见了，前面都推导过了，这里也就不加赘述了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实是标题党啦... SVM 推导作为最臭名昭著的机器学习面试题，其实我在去年的这个时候准备头条实习面试的期间就已经“背诵”过了，但完全没有理解自己推导的是个什么东西。最近看台大的《机器学习技法》的课程视频，感觉这个 SVM 推导过程讲的非常清晰。最关键的是每一步的 motivation 都讲的非常清楚，正好博客也好久好久好久没有更新了，这里简单重复一下，以证明自己学会了 SVM 的推导吧~&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://reku1997.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>GoodBye ICPC</title>
    <link href="https://reku1997.gitee.io/2017/12/20/goodbye-icpc/"/>
    <id>https://reku1997.gitee.io/2017/12/20/goodbye-icpc/</id>
    <published>2017-12-20T01:03:17.000Z</published>
    <updated>2021-12-16T11:33:00.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="心灵之约观光团">2016 心灵之约观光团</h2><ul><li>2016 浙江大学程序设计竞赛 一等奖</li><li>2016 浙江省程序设计竞赛 三等奖</li></ul><h2 id="rkmxtxwd-热裤暮夏天下无敌">2016 rkmxtxwd 热裤暮夏天下无敌</h2><ul><li>2016 ACM/ICPC 大连 银牌  36th place.</li><li>2016 ACM/ICPC 北京 银牌  29th place.</li></ul><h2 id="leatherclub-广东老乡">2017 LeatherClub 广东老乡</h2><ul><li>2017 ACM/ICPC 西安 金牌  17th place.</li><li>2017 CCPC 杭州 金牌  10th place.</li><li>2017 ACM/ICPC 南宁 金牌  9th place.</li><li>2017 ACM/ICPC 上海 ECL-final 铜牌  128th place.</li></ul><p>虽然很想继续...但是明年还要找工作（or 保研？？？），还要为了生计奔波，感觉自己除了竞赛什么都不会...其实竞赛也始终没有变成很强的选手...所以只能说再见了吧...</p><p>GoodBye ICPC</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;心灵之约观光团&quot;&gt;2016 心灵之约观光团&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2016 浙江大学程序设计竞赛 一等奖&lt;/li&gt;
&lt;li&gt;2016 浙江省程序设计竞赛 三等奖&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;rkmxtxwd-热裤暮夏天下无敌&quot;&gt;2016 rkmxt</summary>
      
    
    
    
    <category term="acm" scheme="https://reku1997.gitee.io/categories/acm/"/>
    
    
  </entry>
  
  <entry>
    <title>2017 CCPC 杭州赛区小结 By ruiker @ 广东老乡</title>
    <link href="https://reku1997.gitee.io/2017/11/08/2017-ccpc-hangzhou-by-ruiker-leatherclub/"/>
    <id>https://reku1997.gitee.io/2017/11/08/2017-ccpc-hangzhou-by-ruiker-leatherclub/</id>
    <published>2017-11-08T07:25:16.000Z</published>
    <updated>2021-12-16T14:39:12.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="day-0">Day 0</h2><p>上午和shb/lsmll/sfiction/jtjl从玉泉打车去武林广场，然后坐（站）了一万年的地铁，终于到了浙理工。 <span id="more"></span> 报道之后数次建议jtjl去浙传看看女生都被jtjl拒绝，看起来这个人真的是个给。</p><p>下午就是热身赛，场地小的爆炸，感觉一个过道都容纳不了两个搞学长。热身赛A题，我们一看三分钟就有人过，肯定是个暴力啊，然后喜获TLE，换了个合理复杂度的暴力，才过掉。之后johann写了个大模拟B，我和lzw讨论了半天矩形切割，lzw就去写了个异常扭曲的算法，过掉了C，胜利AK，热身赛rank7。然后我来测试一下环境，发现eclipse好像不太好用啊，似乎无法运行程序，于是被志愿者教做人了。之后我就很贱的跑去shb那里，问他eclipse好不好使呀，然后强行教了shb做人。 赛前的晚上，发现我们队好像没有数列表，妄图抢走jtjl队的数列表，被jtjl怒斥。</p><h2 id="day-1">Day 1</h2><p>这次比赛是复旦大学出题，所以对题目质量期望还是比较高的。johann和lzw瞬间发现签到题A，<strong>A1y5</strong>。我去看了IJKL，感觉J是个**题，就让lzw接着写，<strong>J1y16</strong>。然后此时BCD都有队伍过了，我们三个就分头开BCD，lzw很快会做了B，<strong>B1y26</strong>。然后我和johann讨论了一下，也很快会做了D，<strong>D1y40</strong>。获得了超级顺利的前期。 C题是一个不平衡博弈，看上去就是个智商题。三个人想了半天，感觉没什么思路，他们两个似乎对题意有了些奇怪的理解，就发了一波clarification，结果复旦给了我们一个错误的题意。当时觉得这个题意好难...完全不会做，后来发现按照复旦回答我们的题意，似乎这样根本过不了样例啊？就又发了一个clarification，复旦终于告诉了我们正确的题意...然后我去了趟厕所，猜了个结论，和lzw说了一下，他表示好像有点合理，<strong>C1y76</strong>。</p><p>之后我们三个讨论了一下，很快也讨论出了K的做法，但这个时候复旦又发了个clarification，说题面中的下取整变成了类型强转...然后三个人再次陷入绝望。讨论了半天，终于扭曲的解决掉了这个问题，已经快写了一半，复旦又发了个clarification，说题意不变还是下取整...然后K又出现了一些超时问题，终于<strong>K3y181</strong>。 这时还能在金牌区苟延残喘，我们觉得还是要再过一题才能有金。开了E和G，感觉没有一道题能做。johann试图去开F的大暴力，被我拦住了。三个人一直卡思路卡到了封榜。lzw表示他在被我要求学习FWT的时候，看过一个例题，题意和这个E有一些相似，需要树分治然后怎样怎样搞一搞，但是这个怎样搞的他已经忘了。johann想到了G的一个奇怪的转化，讨论了一下发现只有N^2的递推做法，感觉一看就过不了。但是这个时候反正已经爆炸了，就让johann先上去莽一下。突然lzw说会E的树分治做法了，跟我乱讲一通我听的迷迷糊糊，然后lzw自己好像也不太懂，就上机乱写一通，竟然<strong>E1y272</strong>，害怕极了。</p><p>最后半个小时，我和lzw大致了解了刚才做法的正确性，johann乱搞G，自然没有通过，后来询问一队，发现是个奇怪的按秩NTT？</p><h2 id="经验教训">经验教训</h2><p>杭州强队多，牌子少，感觉能得到金牌完全是侥幸。后期能力实在太不足了啊，根本做不出难题...</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;day-0&quot;&gt;Day 0&lt;/h2&gt;
&lt;p&gt;上午和shb/lsmll/sfiction/jtjl从玉泉打车去武林广场，然后坐（站）了一万年的地铁，终于到了浙理工。&lt;/p&gt;</summary>
    
    
    
    <category term="acm" scheme="https://reku1997.gitee.io/categories/acm/"/>
    
    
    <category term="小结" scheme="https://reku1997.gitee.io/tags/%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2017 ACM/ICPC 西安赛区小结 by ruiker @ 广东老乡</title>
    <link href="https://reku1997.gitee.io/2017/10/31/2017-acmicpc-xian-by-ruiker-leatherclub/"/>
    <id>https://reku1997.gitee.io/2017/10/31/2017-acmicpc-xian-by-ruiker-leatherclub/</id>
    <published>2017-10-31T11:12:12.000Z</published>
    <updated>2021-12-16T14:39:23.143Z</updated>
    
    <content type="html"><![CDATA[<p>lzw视角： <a href="http://www.cnblogs.com/vb4896/p/7754224.html">http://www.cnblogs.com/vb4896/p/7754224.html</a>  </p><span id="more"></span><h2 id="day--1">Day -1</h2><p>一大早和sfiction/zya一起从玉泉出发去机场，前一天上毛概的时候因为台阶太高体重太大，崴了一下脚，走路下楼痛苦异常。星期三和学长们整理模板的时候，发现每个人都要带一大坨模板，lzw甚至还要带一堆数学类书籍，书包感觉要爆炸。 路上sf一直和我们两个讲述实习做些什么以及一些奇奇怪怪的算法题，感觉很diao，没怎么听懂。</p><p>到达西安之后，坐了三个多小时的车，终于到了西北工业大学长安校区，感觉横跨了整个西安，及其偏僻，就在秦岭脚下，是个大农村。坐了总共58站公交车，而且这个公交车异常破烂而且开的十分勇猛，一路上尘土飞扬，到达西工大之后感觉**都要被颠出来了。 在西工大报道的时候，发现每支队伍都要拍一张羞耻照片，滚榜的时候用。在我们后面拍照的是南京大学的三支队伍，三支队伍中竟然有4个妹子，而且还都很可爱，想到浙大集训队已经好久没有女队员了，感觉心情有些复杂。 西工大食堂提供给我们的饭菜卖相异常糟糕，味道也很一般，但还是坚强的吃完了...之后就到达了著名的秦龙温泉酒店，水里面意料之中的有奇怪的水锈，床单上竟然真的有奇怪的血迹，马上叫阿姨来换了一个。房间意外的没有像知乎中说的一样，到处都是用过的避孕套，感觉还是有一丝开心。房间窗户对面就是个KTV，有几个中年老男人唱歌唱了一晚上，心情烦躁。johann过来帮助lzw调红黑树，我则在床上睡觉，因为一些奇怪的原因，lzw的红黑树没有调出来（</p><p>lzw 放弃红黑树之后，三队四队一起出去吃夜宵，发现方圆几公里内好像只有一个饭店，jyw学长在上菜前感觉好像察觉了什么，找了个借口溜了，但是我感觉这个饭店好像还行啊？  </p><h2 id="day-0">Day 0</h2><p>三个人刚到热身赛的现场，johann在试键盘的时候突然发现这个键盘的tab键掉了，感觉要报警。让志愿者去换了个键盘，结果是个游戏键盘，退格键异常的小，感觉更爆炸了。想让志愿者从其他地方扣个tab下来再把我们之前的键盘换回来，可是志愿者说已经没有键盘了，还在不停的道歉，不知道我们的态度是不是过于凶狠... 热身赛赛前五分钟竟然就发了题目，lzw发现A是一个快速幂猜数题，lzw马上打了个快速幂，然后我上来就猜了个2017，比赛开始后10s就交了，发现run id已经是18，似乎已经没有一血了。结果我们竟然拿到了猜数题的一血，一群人过来拍照，瑟瑟发抖，感觉人品已经败光了。 B题是个大模拟，非常的烦，johann写的十分不顺，我和lzw讨论C，发现和七月集训的一道题差不多，用线段树维护一个转换环，所以决定等johann写完上去看看转换环的长度是多少，结果发现并不是一个环，要先转换6次左右才能进入这个转换环，还要魔改一下，记录当前节点进入了状态机的哪个状态。这个时候突然发现UESTC五分钟就过了这个题目，感觉很震撼，似乎是个暴力就能过得题。但是因为是热身赛，所以还是让lzw上机写正解，然而一直在WA。lzw debug的时候，我上去打了个暴力，johann提出了一个小优化，竟然真的AC了，感觉这个数据好垃圾... 之后又测了测栈深度，java什么的，感觉还算合理，lzw的C题正解到最后也没有debug出来。</p><p>晚上回到宾馆，先是和lzw一起debug C题，终于发现了一个很隐秘的错误，对拍了一下感觉是对的。然后在lzw的督促下边看《非诚勿扰》边用java的bigDecimal写去年china final的E，冒泡排序的**方法很快就过了，然而结构体排序研究了半天，感觉排序已经对了，不知道为什么就是过不了，后来终于发现原来是ArrayList没有清空...感觉很傻。经过了一个充实的晚上，11点就上床睡觉了，因为晚上过于充实，直接导致了lzw的概统小测获得了1分的高分。  </p><h2 id="day-1">Day 1</h2><p>有剧透，之后要训这场学长们请谨慎观看</p><p>到了正式赛现场发现键盘竟然换了回去，感觉很开心，昨天凶狠的态度似乎获得了回报。 比赛开始后，题目里面有个标题叫Lover，还有个标题叫Lover 2，johann就唱起了《Hop》，吸引我也跟着唱，感觉有毒。马上johann发现B是个**贪心，然而用set贪了半天，一交就WA掉了。三个人看了一会，感觉也没看出什么错误，后来才发现需要用multiset，<strong>B2y16</strong>。之后我和johann看F，发现好像不会啊，不知道他们是怎么过的，叫来lzw看他也觉得不会...此时感觉我的心态已经有些爆炸了，但是因为平时训练也经常前期爆炸，所以感觉还是比较正常。lzw转去开了G，发现是个很傻的按位处理，就上机去写了。我和johann继续讨论F，johann发现F是一个马尔科夫链的随机游走，然而就我掌握的知识而言，这种题我只会高斯消元，可是数据范围太大了。lzw因为忘记取余，G又WA了一发，改了之后<strong>G2y41</strong>。这个时候F已经过了一堆人，榜上已经看不见我们了。</p><p>lzw发现我们还在卡F，就又去开了H，发现是个**线段树贪心，就接着上去写。我和johann走投无路，只能猜了个公式，lzw的H写的很顺，一下就过了<strong>H1y63</strong>，然后我上机打了F这个猜的公式，竟然也过了<strong>F1y65</strong>，感觉莫名其妙。这个时候我们在榜上冲到了第六名，获得了本场比赛的巅峰。三个人的心态有所好转。 然后lzw发现A只要线段树维护一下线性基合并就好了，也没有仔细算时间复杂度，上来就开始写，赛后sf说我们的时间复杂度其实不太合理的...然后lzw写好之后，我去看了一眼，发现在算线性基之前有个小地方需要按位处理一下，就让lzw改了改。交了就过了<strong>A1y92</strong>。在lzw写A的时候，我和Johann很快想到了枚举然后bitset优化容斥的做法，我上机开始写，很快写完了。发现样例及其难输入，是一个长度为500的随机01串，非常的烦。我敲了半天样例发现不知道哪里多敲了一位，心态瞬间爆炸，想不测样例了直接交题吧，被Johann摁住，然后Johann开始输入样例，发现果然没过样例，找了几个奇怪的错误，终于通过了样例，交了就过了<strong>J1y143</strong>。这个时候我们是全场第9名。</p><p>看了看后面的题目，EIK都有人过，但是都不超过五个人，但是感觉要想拿到金牌，可能还是要再过一题。虽然后来发现，就算我们之后没过题也是有金的。 很快我们讨论起了K，lzw很快表示这个题肯定要用到Hall定理，但是怎么用不是很清楚。然后我们很快发现只要看看每个子集的最大值对应的lover个数就好了。然后lzw和Johann分别提出了一个转化，我们都觉得Johann那个转化好像比较妙，但是想了半天都不会，就回到了lzw的转化，然后我很快发现lzw的转化可以用莫队+线段树来维护（怎么tm又是线段树），但是感觉复杂度爆炸。就先让lzw上去莽，我掏出了莫队的板子想让lzw抄，结果lzw说“莫队很简单的，我闭着眼睛也不会写错”。写完之后喜获TLE。 然后我们陷入僵局，lzw和johann看起了I，我接着想K，他俩很快发现这个I好像也是个莫队啊，因为维护的数字不超过10个，所以随便搞搞就行了。然后把K写好的莫队复制了上去，写完一交，又是TLE。看了半天，感觉没什么bug，如果是个卡常数题目，那就很绝望了。我们在本地gen了一个大数据，发现奇慢无比。然后看了一下，发现莫队忘排序了...排了序一交，又是WA。 然后我掏出了莫队板子来对代码，发现lzw的莫队顺序写错了...改完一交<strong>I3y269</strong>。 最后30分钟给我乱搞K，交了一万遍，还是没过。赛后发现标准算法是把我们的莫队优化掉了，其实只要two pointer一下就好了，感觉非常傻，不知道为什么四队没想到我们也没想到。 赛后sf一直说要迟到啦，让我们鸽掉滚榜和颁奖典礼，导致我们没有领到奖牌也看不到终榜。结果提前四个小时到达咸阳机场，gtmsf。</p><p>最后结果是我们第17名，四队第21名，七队第58名，总共357支队伍。我们和四队是金牌，七队是银牌，都还算比较满意的成绩。我打了两年ACM，也拿到了第一个金牌...可惜队友和去年已经不一样，我永远弥补不了去年北京写错上下界网络流的遗憾了..  </p><h2 id="经验教训">经验教训</h2><ul><li>这场比赛题目质量似乎比较一般，不知道为什么有这么多线段树，所以lzw写的题目太多了，感觉lzw被掏空</li><li>reku这个**连个ST表都要抄板子，怕不是个残疾人？</li><li>不要过于自信，必要时要多看模板</li><li>最后比较大的失误是K题一直沉浸在莫队中无法自拔，其实K比I要简单多了，我们应该有能力8题的</li><li>明年去西安的学长们千万不要住秦龙</li><li>告诉带队教练，从西工大打车去咸阳机场，很稳的，只要教练付钱就好了</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;lzw视角： &lt;a href=&quot;http://www.cnblogs.com/vb4896/p/7754224.html&quot;&gt;http://www.cnblogs.com/vb4896/p/7754224.html&lt;/a&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="acm" scheme="https://reku1997.gitee.io/categories/acm/"/>
    
    
    <category term="小结" scheme="https://reku1997.gitee.io/tags/%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>后缀自动机</title>
    <link href="https://reku1997.gitee.io/2017/09/28/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>https://reku1997.gitee.io/2017/09/28/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/</id>
    <published>2017-09-28T14:27:51.000Z</published>
    <updated>2021-12-16T12:15:01.837Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道后缀自动机的构造是比较难以理解的，所以我想先知道后缀自动机构建出来的东西是什么。 <span id="more"></span> 首先后缀自动机构造出来的一定是一个自动机，这个自动机可以接收一个字符串所有的后缀，显然这个自动机是一个DAG图。 然后这个自动机的每个状态代表什么呢？代表结束位置相同的子串，比如ab和aab在aabaab中都在<span class="math inline">\(3,6\)</span>位置结尾，那么这两个串可以认为在后缀自动机中是同一个状态。 后缀自动机大概维护这么几个东西：</p><p><span class="math inline">\(MAXLEN[ST]\)</span> : <span class="math inline">\(ST\)</span>对应的最长的字符串</p><p><span class="math inline">\(MINLEN[ST]\)</span> : <span class="math inline">\(ST\)</span>对应的最短的字符串</p><p><span class="math inline">\(TRANS[ST][]\)</span> : <span class="math inline">\(ST\)</span>对应的转移函数</p><p><span class="math inline">\(SLINK[ST]\)</span> : <span class="math inline">\(ST\)</span>对应的最小的超集，比如<span class="math inline">\((3,6,9)\)</span>是<span class="math inline">\((3,6)\)</span>的超集。</p><p><span class="math inline">\(SLINK\)</span>指向的状态一定是当前状态的一个前缀，而且形成的一定是一棵树</p><p><span class="math inline">\(ENDPOS[ST]\)</span> : <span class="math inline">\(ST\)</span>状态包含的子串的结束位置个数，可以通过<span class="math inline">\(SLINK\)</span>树自底向上来求出</p><p>至于这个后缀自动机的构造方法，就抄个板子？</p><p><a href="http://hihocoder.com/problemset/problem/1445">http://hihocoder.com/problemset/problem/1445</a></p><blockquote><p>小Hi平时的一大兴趣爱好就是演奏钢琴。我们知道一个音乐旋律被表示为一段数构成的数列。 现在小Hi想知道一部作品中出现了多少不同的旋律？</p></blockquote><p>这个不同旋律出现的次数，对于每个状态，不同的子串个数为<span class="math inline">\(maxlen-minlen+1\)</span>，然后对每个状态算一算就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXL + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, len, st;</span><br><span class="line"><span class="keyword">int</span> maxlen[<span class="number">2</span> * MAXL + <span class="number">10</span>], minlen[<span class="number">2</span> * MAXL + <span class="number">10</span>], trans[<span class="number">2</span> * MAXL + <span class="number">10</span>][<span class="number">26</span>], slink[<span class="number">2</span> * MAXL + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_state</span><span class="params">(<span class="keyword">int</span> _maxlen, <span class="keyword">int</span> _minlen, <span class="keyword">int</span>* _trans, <span class="keyword">int</span> _slink)</span> </span>&#123;</span><br><span class="line">        maxlen[n] = _maxlen;</span><br><span class="line">        minlen[n] = _minlen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(_trans == <span class="literal">NULL</span>)</span><br><span class="line">                        trans[n][i] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        trans[n][i] = _trans[i];</span><br><span class="line">        &#125;</span><br><span class="line">        slink[n] = _slink;</span><br><span class="line">        <span class="keyword">return</span> n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> z = <span class="built_in">new_state</span>(maxlen[u] + <span class="number">1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> v = u;</span><br><span class="line">        <span class="keyword">while</span>(v != <span class="number">-1</span> &amp;&amp; trans[v][c] == <span class="number">-1</span>) &#123;</span><br><span class="line">                trans[v][c] = z;</span><br><span class="line">                v = slink[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) &#123; <span class="comment">//最简单的情况，suffix-path(u-&gt;S)上都没有对应字符ch的转移</span></span><br><span class="line">                minlen[z] = <span class="number">1</span>;</span><br><span class="line">                slink[z] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = trans[v][c];</span><br><span class="line">        <span class="keyword">if</span>(maxlen[v] + <span class="number">1</span> == maxlen[x]) &#123; <span class="comment">//较简单的情况，不用拆分x</span></span><br><span class="line">                minlen[z] = maxlen[x] + <span class="number">1</span>;</span><br><span class="line">                slink[z] = x;</span><br><span class="line">                <span class="keyword">return</span> z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">new_state</span>(maxlen[v] + <span class="number">1</span>, <span class="number">-1</span>, trans[x], slink[x]); <span class="comment">//最复杂的情况，拆分x</span></span><br><span class="line">        slink[y] = slink[x];</span><br><span class="line">        minlen[x] = maxlen[y] + <span class="number">1</span>;</span><br><span class="line">        slink[x] = y;</span><br><span class="line">        minlen[z] = maxlen[y] + <span class="number">1</span>;</span><br><span class="line">        slink[z] = y;</span><br><span class="line">        <span class="keyword">int</span> w = v;</span><br><span class="line">        <span class="keyword">while</span>(w != <span class="number">-1</span> &amp;&amp; trans[w][c] == x) &#123;</span><br><span class="line">                trans[w][c] = y;</span><br><span class="line">                w = slink[w];</span><br><span class="line">        &#125;</span><br><span class="line">        minlen[y] = maxlen[slink[y]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">st=<span class="built_in">new_state</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line">st=<span class="built_in">add_char</span>(s[i],st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=maxlen[i]-minlen[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://hihocoder.com/problemset/problem/1449">http://hihocoder.com/problemset/problem/1449</a></p><blockquote><p>小Hi平时的一大兴趣爱好就是演奏钢琴。我们知道一个音乐旋律被表示为一段数构成的数列。 现在小Hi想知道一部作品中所有长度为K的旋律中出现次数最多的旋律的出现次数。但是K不是固定的，小Hi想知道对于所有的K的答案。</p></blockquote><p>通过<span class="math inline">\(slink\)</span>树，我们可以构建出每个状态的结束位置个数，这样的话就知道了每个<span class="math inline">\(maxlen\)</span>出现了多少次，因为最后的答案一定是按照长度单调递减的，所以就维护一个类似于前缀最大值就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> maxlen, minlen, slink;</span><br><span class="line">  <span class="keyword">int</span> trans[M];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">state st[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> degree[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> endpos[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> prefix[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> size, last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_state</span><span class="params">(<span class="keyword">int</span> maxlen, <span class="keyword">int</span> minlen, <span class="keyword">int</span> slink, <span class="keyword">int</span> *trans)</span> </span>&#123;</span><br><span class="line">  prefix[size] = <span class="literal">false</span>;</span><br><span class="line">  degree[size] = <span class="number">0</span>;</span><br><span class="line">  endpos[size] = <span class="number">0</span>;</span><br><span class="line">  st[size].maxlen = maxlen;</span><br><span class="line">  st[size].minlen = minlen;</span><br><span class="line">  st[size].slink = slink;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trans == <span class="literal">NULL</span>)</span><br><span class="line">      st[size].trans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      st[size].trans[i] = trans[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = ch - <span class="string">&#x27;a&#x27;</span>, v, x, y;</span><br><span class="line">  <span class="keyword">int</span> cur = <span class="built_in">new_state</span>(st[u].maxlen + <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">  prefix[cur] = <span class="literal">true</span>;</span><br><span class="line">  endpos[cur] = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (v = u; v != <span class="number">-1</span> &amp;&amp; st[v].trans[c] == <span class="number">-1</span>; v = st[v].slink) &#123;</span><br><span class="line">    st[v].trans[c] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">-1</span>) &#123;</span><br><span class="line">    st[cur].minlen = <span class="number">1</span>;</span><br><span class="line">    st[cur].slink = <span class="number">0</span>;</span><br><span class="line">    degree[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  x = st[v].trans[c];</span><br><span class="line">  <span class="keyword">if</span> (st[v].maxlen + <span class="number">1</span> == st[x].maxlen) &#123;</span><br><span class="line">    st[cur].minlen = st[x].maxlen + <span class="number">1</span>;</span><br><span class="line">    st[cur].slink = x;</span><br><span class="line">    degree[x]++;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  y = <span class="built_in">new_state</span>(st[v].maxlen + <span class="number">1</span>, <span class="number">-1</span>, st[x].slink, st[x].trans);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w = v; w != <span class="number">-1</span> &amp;&amp; st[w].trans[c] == x; w = st[w].slink)</span><br><span class="line">    st[w].trans[c] = y;</span><br><span class="line">  st[x].slink = st[cur].slink = y;</span><br><span class="line">  degree[y] += <span class="number">2</span>;</span><br><span class="line">  st[x].minlen = st[cur].minlen = st[y].maxlen + <span class="number">1</span>;</span><br><span class="line">  st[y].minlen = st[st[y].slink].maxlen + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (degree[i] == <span class="number">0</span>)</span><br><span class="line">      q.<span class="built_in">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    endpos[st[x].slink] += endpos[x];</span><br><span class="line">    <span class="keyword">if</span> (--degree[st[x].slink] == <span class="number">0</span>)</span><br><span class="line">      q.<span class="built_in">push</span>(st[x].slink);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  last = <span class="built_in">new_state</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line">last=<span class="built_in">add_char</span>(s[i],last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">topo</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[st[i].maxlen]=<span class="built_in">max</span>(ans[st[i].maxlen],endpos[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=<span class="built_in">max</span>(ans[i],ans[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://hihocoder.com/problemset/problem/1457">http://hihocoder.com/problemset/problem/1457</a></p><blockquote><p>小Hi平时的一大兴趣爱好就是演奏钢琴。我们知道一段音乐旋律可以被表示为一段数构成的数列。 神奇的是小Hi发现了一部名字叫《十进制进行曲大全》的作品集，顾名思义，这部作品集里有许多作品，但是所有的作品有一个共同特征：只用了十个音符，所有的音符都表示成0-9的数字。 现在小Hi想知道这部作品中所有不同的旋律的“和”（也就是把串看成数字，在十进制下的求和，允许有前导0）。答案有可能很大，我们需要对（10^9 + 7)取摸。</p></blockquote><p>用像后缀数组处理多串的方法，把所有的串都串起来，然后在DAG跑个DP套DP就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> maxlen, minlen, slink;</span><br><span class="line">  <span class="keyword">int</span> trans[M];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">state st[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> degree[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> endpos[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> prefix[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> indegree[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> valad[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="keyword">char</span> s[N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> c[N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> size, last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_state</span><span class="params">(<span class="keyword">int</span> maxlen, <span class="keyword">int</span> minlen, <span class="keyword">int</span> slink, <span class="keyword">int</span> *trans)</span> </span>&#123;</span><br><span class="line">  prefix[size] = <span class="literal">false</span>;</span><br><span class="line">  degree[size] = <span class="number">0</span>;</span><br><span class="line">  endpos[size] = <span class="number">0</span>;</span><br><span class="line">  st[size].maxlen = maxlen;</span><br><span class="line">  st[size].minlen = minlen;</span><br><span class="line">  st[size].slink = slink;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trans == <span class="literal">NULL</span>)</span><br><span class="line">      st[size].trans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      st[size].trans[i] = trans[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = ch - <span class="string">&#x27;0&#x27;</span>, v, x, y;</span><br><span class="line">  <span class="keyword">int</span> cur = <span class="built_in">new_state</span>(st[u].maxlen + <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">  prefix[cur] = <span class="literal">true</span>;</span><br><span class="line">  endpos[cur] = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (v = u; v != <span class="number">-1</span> &amp;&amp; st[v].trans[c] == <span class="number">-1</span>; v = st[v].slink) &#123;</span><br><span class="line">    st[v].trans[c] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">-1</span>) &#123;</span><br><span class="line">    st[cur].minlen = <span class="number">1</span>;</span><br><span class="line">    st[cur].slink = <span class="number">0</span>;</span><br><span class="line">    degree[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  x = st[v].trans[c];</span><br><span class="line">  <span class="keyword">if</span> (st[v].maxlen + <span class="number">1</span> == st[x].maxlen) &#123;</span><br><span class="line">    st[cur].minlen = st[x].maxlen + <span class="number">1</span>;</span><br><span class="line">    st[cur].slink = x;</span><br><span class="line">    degree[x]++;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  y = <span class="built_in">new_state</span>(st[v].maxlen + <span class="number">1</span>, <span class="number">-1</span>, st[x].slink, st[x].trans);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w = v; w != <span class="number">-1</span> &amp;&amp; st[w].trans[c] == x; w = st[w].slink)</span><br><span class="line">    st[w].trans[c] = y;</span><br><span class="line">  st[x].slink = st[cur].slink = y;</span><br><span class="line">  degree[y] += <span class="number">2</span>;</span><br><span class="line">  st[x].minlen = st[cur].minlen = st[y].maxlen + <span class="number">1</span>;</span><br><span class="line">  st[y].minlen = st[st[y].slink].maxlen + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (degree[i] == <span class="number">0</span>)</span><br><span class="line">      q.<span class="built_in">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    endpos[st[x].slink] += endpos[x];</span><br><span class="line">    <span class="keyword">if</span> (--degree[st[x].slink] == <span class="number">0</span>)</span><br><span class="line">      q.<span class="built_in">push</span>(st[x].slink);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  last = <span class="built_in">new_state</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">  valad[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,c+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ll=<span class="built_in">strlen</span>(c+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(len!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">s[len]=<span class="string">&#x27;0&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=ll;j++)</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">s[len]=c[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line">last=<span class="built_in">add_char</span>(s[i],last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(st[i].trans[j]!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">indegree[st[i].trans[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">sum=(ans[t]+sum)%mod;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=st[t].trans[i];</span><br><span class="line"><span class="keyword">if</span>(v==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">valad[v]=(valad[v]+valad[t])%mod;</span><br><span class="line">ans[v]=(ans[v]+ans[t]*<span class="number">10</span>+i*valad[t])%mod;</span><br><span class="line">&#125;</span><br><span class="line">indegree[v]--;</span><br><span class="line"><span class="keyword">if</span>(indegree[v]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://hihocoder.com/problemset/problem/1465">http://hihocoder.com/problemset/problem/1465</a></p><blockquote><p>小Hi平时的一大兴趣爱好就是演奏钢琴。我们知道一段音乐旋律可以被表示为一段数构成的数列。 小Hi发现旋律可以循环，每次把一段旋律里面最前面一个音换到最后面就成为了原旋律的“循环相似旋律”，还可以对“循环相似旋律”进行相同的变换能继续得到原串的“循环相似旋律”。 小Hi对此产生了浓厚的兴趣，他有若干段旋律，和一部音乐作品。对于每一段旋律，他想知道有多少在音乐作品中的子串（重复便多次计）和该旋律是“循环相似旋律”。</p></blockquote><p>对于循环同构的一个处理方法就是把字符串翻倍，然后看看最长公共子串是不是大于<span class="math inline">\(N\)</span>，问题就是怎么求这个最长公共子串。 我们用类似kmp的方法处理，然后用endpos记一下数，就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> maxlen, minlen, slink;</span><br><span class="line">  <span class="keyword">int</span> trans[M];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">state st[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> degree[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> endpos[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> prefix[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N * <span class="number">2</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> s[N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> t[N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> size, last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_state</span><span class="params">(<span class="keyword">int</span> maxlen, <span class="keyword">int</span> minlen, <span class="keyword">int</span> slink, <span class="keyword">int</span> *trans)</span> </span>&#123;</span><br><span class="line">  prefix[size] = <span class="literal">false</span>;</span><br><span class="line">  degree[size] = <span class="number">0</span>;</span><br><span class="line">  endpos[size] = <span class="number">0</span>;</span><br><span class="line">  st[size].maxlen = maxlen;</span><br><span class="line">  st[size].minlen = minlen;</span><br><span class="line">  st[size].slink = slink;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trans == <span class="literal">NULL</span>)</span><br><span class="line">      st[size].trans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      st[size].trans[i] = trans[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = ch - <span class="string">&#x27;a&#x27;</span>, v, x, y;</span><br><span class="line">  <span class="keyword">int</span> cur = <span class="built_in">new_state</span>(st[u].maxlen + <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">  prefix[cur] = <span class="literal">true</span>;</span><br><span class="line">  endpos[cur] = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (v = u; v != <span class="number">-1</span> &amp;&amp; st[v].trans[c] == <span class="number">-1</span>; v = st[v].slink) &#123;</span><br><span class="line">    st[v].trans[c] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">-1</span>) &#123;</span><br><span class="line">    st[cur].minlen = <span class="number">1</span>;</span><br><span class="line">    st[cur].slink = <span class="number">0</span>;</span><br><span class="line">    degree[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  x = st[v].trans[c];</span><br><span class="line">  <span class="keyword">if</span> (st[v].maxlen + <span class="number">1</span> == st[x].maxlen) &#123;</span><br><span class="line">    st[cur].minlen = st[x].maxlen + <span class="number">1</span>;</span><br><span class="line">    st[cur].slink = x;</span><br><span class="line">    degree[x]++;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  y = <span class="built_in">new_state</span>(st[v].maxlen + <span class="number">1</span>, <span class="number">-1</span>, st[x].slink, st[x].trans);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w = v; w != <span class="number">-1</span> &amp;&amp; st[w].trans[c] == x; w = st[w].slink)</span><br><span class="line">    st[w].trans[c] = y;</span><br><span class="line">  st[x].slink = st[cur].slink = y;</span><br><span class="line">  degree[y] += <span class="number">2</span>;</span><br><span class="line">  st[x].minlen = st[cur].minlen = st[y].maxlen + <span class="number">1</span>;</span><br><span class="line">  st[y].minlen = st[st[y].slink].maxlen + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (degree[i] == <span class="number">0</span>)</span><br><span class="line">      q.<span class="built_in">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    endpos[st[x].slink] += endpos[x];</span><br><span class="line">    <span class="keyword">if</span> (--degree[st[x].slink] == <span class="number">0</span>)</span><br><span class="line">      q.<span class="built_in">push</span>(st[x].slink);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  last = <span class="built_in">new_state</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ff</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">&#123;</span><br><span class="line">vis[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line">t[len+i]=t[i];</span><br><span class="line">&#125;</span><br><span class="line">len*=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> u,l;</span><br><span class="line">u=l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=t[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(u!=<span class="number">0</span> &amp;&amp; st[u].trans[v]==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">u=st[u].slink;</span><br><span class="line">l=st[u].maxlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(st[u].trans[v]!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">u=st[u].trans[v];</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">u=l=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l&gt;len/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(st[st[u].slink].maxlen&gt;=len/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">u=st[u].slink;</span><br><span class="line">l=st[u].maxlen;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=len/<span class="number">2</span> &amp;&amp; vis[u]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">ans+=endpos[u];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">&#123;</span><br><span class="line">last = <span class="built_in">add_char</span>(s[i],last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">topo</span>();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ff</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们都知道后缀自动机的构造是比较难以理解的，所以我想先知道后缀自动机构建出来的东西是什么。&lt;/p&gt;</summary>
    
    
    
    <category term="acm" scheme="https://reku1997.gitee.io/categories/acm/"/>
    
    
    <category term="后缀自动机" scheme="https://reku1997.gitee.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>虚树</title>
    <link href="https://reku1997.gitee.io/2017/09/20/%E8%99%9A%E6%A0%91/"/>
    <id>https://reku1997.gitee.io/2017/09/20/%E8%99%9A%E6%A0%91/</id>
    <published>2017-09-20T05:08:47.000Z</published>
    <updated>2020-06-09T12:01:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实虚树这一套没什么，就是一个板子。主要解决的是给一个树，然后对树上的某个点集搞些什么操作啊询问啊，之类的问题。 就是把原树的dfs序搞出来，然后把要搞的点和lca拿出来，搞一棵新的树，用单调栈来时限，其实就是一个模板。 例题是<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3611">bzoj 3611</a></p><span id="more"></span><blockquote><p>给定一棵树，然后询问一个点集的所有互相之间的路径和以及最长路径最短路径</p></blockquote><p>把虚树建出来，然后就树dp随便维护最长链最短链就好了，很显然。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000005</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Map[MAXN];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL asum,amin,amax;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1000000</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,<span class="number">1000000</span>,stdin),p1==p2)?EOF:*p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">rea</span><span class="params">(<span class="keyword">int</span> &amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">nc</span>();x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">nc</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">nc</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">rea</span><span class="params">(LL &amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">nc</span>();x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">nc</span>());</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">nc</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">voidTree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000005</span>,LOG = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN],out[MAXN],dep[MAXN],f[MAXN][LOG + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,LL&gt; &gt; tree[MAXN];</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; a;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">int</span> tot,root,n;</span><br><span class="line">LL smin[MAXN],smax[MAXN],ssum[MAXN],g[MAXN],ct[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> _n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = _n;</span><br><span class="line">root = <span class="number">1</span>; tot = <span class="number">0</span>; <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=LOG;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f[j][i] = f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[u][<span class="number">0</span>] = fa;</span><br><span class="line">dfn[u] = ++tot;</span><br><span class="line">dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Map[u].<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;<span class="keyword">int</span> v = Map[u][i];</span><br><span class="line"><span class="keyword">if</span> (v!=fa) <span class="built_in">dfs</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">out[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=LOG;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span> (dep[f[u][i]] &gt;= dep[v]) u = f[u][i];</span><br><span class="line"><span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=LOG;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span> (f[u][i] != f[v][i])&#123;</span><br><span class="line">u = f[u][i];</span><br><span class="line">v = f[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (dfn[v]&gt;=dfn[u]+<span class="number">1</span> &amp;&amp; dfn[v]&lt;=out[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa=<span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ssum[u]=<span class="number">0</span>; g[u]=<span class="number">0</span>; ct[u]=<span class="number">0</span>; smax[u]=<span class="number">-1</span>; smin[u]=(<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>);</span><br><span class="line"><span class="keyword">if</span>(flag[u])</span><br><span class="line">&#123;</span><br><span class="line">smax[u]=<span class="number">0</span>;</span><br><span class="line">smin[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[u].<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,LL&gt; x = tree[u][i];</span><br><span class="line"><span class="keyword">int</span> v=x.first;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dp</span>(v,u);</span><br><span class="line">ssum[u]+=ct[v]*g[u]+ct[u]*(g[v]+ct[v]*x.second);</span><br><span class="line"><span class="keyword">if</span>(smax[u]!=<span class="number">-1</span>&amp;&amp;smax[v]!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">amax=<span class="built_in">max</span>(amax,smax[u]+smax[v]+x.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(smin[u]!=(<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>)&amp;&amp;smin[v]!=(<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>))</span><br><span class="line">&#123;</span><br><span class="line">amin=<span class="built_in">min</span>(amin,smin[u]+smin[v]+x.second);</span><br><span class="line">&#125;</span><br><span class="line">smax[u]=<span class="built_in">max</span>(smax[u],smax[v]+x.second);</span><br><span class="line">smin[u]=<span class="built_in">min</span>(smin[u],smin[v]+x.second);</span><br><span class="line"><span class="keyword">if</span>(flag[u])</span><br><span class="line">&#123;</span><br><span class="line">ssum[u]+=g[v]+ct[v]*x.second;</span><br><span class="line">&#125;</span><br><span class="line">g[u]+=g[v]+ct[v]*x.second;</span><br><span class="line">ct[u]+=ct[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag[u]) ct[u]++;</span><br><span class="line">asum+=ssum[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nodes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line">root = nodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nodes.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = nodes[i];</span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dfn[x],x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,m=a.<span class="built_in">size</span>();i&lt;m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">lca</span>(a[i].second,a[i<span class="number">-1</span>].second);</span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dfn[x],x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x = a[i];</span><br><span class="line">flag[x.second] = <span class="literal">false</span>;</span><br><span class="line">tree[x.second].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nodes.<span class="built_in">size</span>();i++)&#123; <span class="keyword">int</span> x=nodes[i]; flag[x] = <span class="literal">true</span>;&#125;</span><br><span class="line">a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()),a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x = a[i];</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">check</span>(s.<span class="built_in">top</span>(),x.second)) s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">empty</span>()) s.<span class="built_in">push</span>(x.second);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tree[s.<span class="built_in">top</span>()].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(x.second,dep[x.second] - dep[s.<span class="built_in">top</span>()]));<span class="comment">//s.top()是x.second的父亲 </span></span><br><span class="line">tree[x.second].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(s.<span class="built_in">top</span>(),dep[x.second] - dep[s.<span class="built_in">top</span>()]));<span class="comment">//非双向则注释掉 </span></span><br><span class="line">s.<span class="built_in">push</span>(x.second);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; VT;</span><br><span class="line"><span class="keyword">int</span> n,q,k;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">rea</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">rea</span>(a); <span class="built_in">rea</span>(b);</span><br><span class="line">Map[a].<span class="built_in">pb</span>(b);</span><br><span class="line">Map[b].<span class="built_in">pb</span>(a);</span><br><span class="line">&#125;</span><br><span class="line">VT.<span class="built_in">set</span>(n);</span><br><span class="line"><span class="built_in">rea</span>(q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rea</span>(k);</span><br><span class="line">tmp.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">int</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rea</span>(u);</span><br><span class="line">tmp.<span class="built_in">pb</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">VT.<span class="built_in">create</span>(tmp);</span><br><span class="line">asum=<span class="number">0ll</span>; amin=(<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>); amax=<span class="number">0ll</span>;</span><br><span class="line">VT.<span class="built_in">dp</span>(VT.root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lldn&quot;</span>,asum,amin,amax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实虚树这一套没什么，就是一个板子。主要解决的是给一个树，然后对树上的某个点集搞些什么操作啊询问啊，之类的问题。 就是把原树的dfs序搞出来，然后把要搞的点和lca拿出来，搞一棵新的树，用单调栈来时限，其实就是一个模板。 例题是&lt;a href=&quot;http://www.lydsy.com/JudgeOnline/problem.php?id=3611&quot;&gt;bzoj 3611&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="acm" scheme="https://reku1997.gitee.io/categories/acm/"/>
    
    
    <category term="树DP" scheme="https://reku1997.gitee.io/tags/%E6%A0%91DP/"/>
    
    <category term="虚树" scheme="https://reku1997.gitee.io/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #417 (Div. 2) E</title>
    <link href="https://reku1997.gitee.io/2017/06/04/codeforces-round-417-div-2-e/"/>
    <id>https://reku1997.gitee.io/2017/06/04/codeforces-round-417-div-2-e/</id>
    <published>2017-06-04T14:45:05.000Z</published>
    <updated>2021-12-16T11:33:15.024Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/812/problem/E">E. Sagheer and Apple Tree</a> 这场比赛的其余题目都比较无聊，不过这个博弈题倒是很有意思。 <span id="more"></span> 然后我仔细看题的时候发现看错题了...md... 如果没看错能不能想出来呢？ 因为从根到叶子节点的路径长度奇偶性相同，所以我们可以根据根到某个点的路径长度来进行染色。 奇偶性和叶子节点相同的染成红色，否则染成黑色。 如果某些苹果从红色节点丢到了黑色节点或者从红色节点被吃掉，那么这个动作相当于取石子游戏中的取石子，游戏正常继续。 如果某些苹果从黑色节点丢到了红色节点，那么先手可以把苹果丢回去。 于是sg值就是红色节点的a[i]的异或和。 用个桶维护一下就能算出答案了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; e[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">40000010</span>];</span><br><span class="line"><span class="keyword">int</span> co[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(e[x].<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">co[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:e[x]) <span class="built_in">ff</span>(i);</span><br><span class="line"> co[x]=!co[e[x][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">e[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ff</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(co[i]==<span class="number">1</span>) sg^=a[i];</span><br><span class="line"><span class="keyword">else</span> num[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(co[i]==<span class="number">1</span>) ans+=num[sg^a[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> numa=<span class="number">0ll</span>,numb=<span class="number">0ll</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(co[i]==<span class="number">1</span>) numa++;</span><br><span class="line"><span class="keyword">else</span> numb++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sg==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans+=numa*(numa<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">ans+=numb*(numb<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/812/problem/E&quot;&gt;E. Sagheer and Apple Tree&lt;/a&gt; 这场比赛的其余题目都比较无聊，不过这个博弈题倒是很有意思。&lt;/p&gt;</summary>
    
    
    
    <category term="acm" scheme="https://reku1997.gitee.io/categories/acm/"/>
    
    
    <category term="codeforces" scheme="https://reku1997.gitee.io/tags/codeforces/"/>
    
    <category term="博弈" scheme="https://reku1997.gitee.io/tags/%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>计蒜之道2017</title>
    <link href="https://reku1997.gitee.io/2017/06/04/%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017/"/>
    <id>https://reku1997.gitee.io/2017/06/04/%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017/</id>
    <published>2017-06-04T07:10:58.000Z</published>
    <updated>2020-06-09T12:01:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nanti.jisuanke.com/t/15769">UCloud 的安全秘钥（困难）</a> 第一次接触到这种hash，感觉很有趣。 而且这种长度的思路其实也是见识过的..为什么想不到呢... <span id="more"></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> s[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> p[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> t[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">bool</span> v[<span class="number">50010</span>];</span><br><span class="line">vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; ha[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r=ha[x].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(ha[x][mid]&lt;e) l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ha[x][l]!=e) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pp=l;</span><br><span class="line">r=ha[x].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ha[x][mid]&gt;e) r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l-pp+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i]=p[i<span class="number">-1</span>]*<span class="number">233</span>+<span class="number">17</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">s[i]=s[i<span class="number">-1</span>]+p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=u;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">t[j]=t[j<span class="number">-1</span>]+p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v[u]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">v[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j+u<span class="number">-1</span>&gt;n) <span class="keyword">break</span>;</span><br><span class="line">ha[u].<span class="built_in">push_back</span>(s[j+u<span class="number">-1</span>]-s[j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ha[u].<span class="built_in">begin</span>(),ha[u].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%dn&quot;</span>,<span class="built_in">ff</span>(u,t[u]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://nanti.jisuanke.com/t/15769&quot;&gt;UCloud 的安全秘钥（困难）&lt;/a&gt; 第一次接触到这种hash，感觉很有趣。 而且这种长度的思路其实也是见识过的..为什么想不到呢...&lt;/p&gt;</summary>
    
    
    
    <category term="acm" scheme="https://reku1997.gitee.io/categories/acm/"/>
    
    
    <category term="计蒜客" scheme="https://reku1997.gitee.io/tags/%E8%AE%A1%E8%92%9C%E5%AE%A2/"/>
    
    <category term="hash" scheme="https://reku1997.gitee.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #416 (Div. 2)</title>
    <link href="https://reku1997.gitee.io/2017/05/31/codeforces-round-416-div-2/"/>
    <id>https://reku1997.gitee.io/2017/05/31/codeforces-round-416-div-2/</id>
    <published>2017-05-31T10:42:53.000Z</published>
    <updated>2021-12-16T12:10:02.875Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/811/problem/A">A. Vladik and Courtesy</a> 二分查找一下次数就行 <span id="more"></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ff1</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r=<span class="number">27483600</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid=(l+r)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid*mid&gt;x) r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ff2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r=<span class="number">27483600</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid=(l+r)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>((mid+<span class="number">1</span>)*mid&gt;x) r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k1=<span class="built_in">ff1</span>(a);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k2=<span class="built_in">ff2</span>(b);</span><br><span class="line"><span class="keyword">if</span>(k1&gt;k2)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Valera&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Vladik&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codeforces.com/contest/811/problem/B">B. Vladik and Complicated Book</a> 暴力<span class="math inline">\(N^2\)</span>计数就行，很傻</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l,r,x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++) <span class="keyword">if</span>(p[j]&lt;=p[x]) num++;</span><br><span class="line"><span class="keyword">if</span>(num==(x-l+<span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codeforces.com/contest/811/problem/C">C. Vladik and Memorable Trip</a> 计算出要覆盖每个值的最小块的大小，然后标记一下。以为是最小块，所以两个块要么互相独立，要么包含，这样直接树dp，来选择块就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> ma[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> mi[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> pp[<span class="number">5010</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; e[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">5010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=t[x];</span><br><span class="line"><span class="keyword">int</span> ans1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:e[x])</span><br><span class="line">&#123;</span><br><span class="line">ans1+=<span class="built_in">ff</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,ans1);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(pp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pp));</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5000</span>;i++) mi[i]=<span class="number">2147483600</span>,ma[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i],mi[a[i]]=<span class="built_in">min</span>(i,mi[a[i]]),ma[a[i]]=<span class="built_in">max</span>(ma[a[i]],i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line"><span class="keyword">if</span>(ma[i]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> zz=mi[i];</span><br><span class="line"><span class="keyword">int</span> yy=ma[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=mi[i];j&lt;=ma[i];j++)</span><br><span class="line">&#123;</span><br><span class="line">zz=<span class="built_in">min</span>(zz,mi[a[j]]);</span><br><span class="line">yy=<span class="built_in">max</span>(yy,ma[a[j]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l=mi[i];</span><br><span class="line"><span class="keyword">int</span> r=ma[i];</span><br><span class="line"><span class="keyword">while</span>(l!=zz||r!=yy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l!=zz)</span><br><span class="line">&#123;</span><br><span class="line">l--;</span><br><span class="line">zz=<span class="built_in">min</span>(zz,mi[a[l]]);</span><br><span class="line">yy=<span class="built_in">max</span>(yy,ma[a[l]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r!=yy)</span><br><span class="line">&#123;</span><br><span class="line">r++;</span><br><span class="line">zz=<span class="built_in">min</span>(zz,mi[a[r]]);</span><br><span class="line">yy=<span class="built_in">max</span>(yy,ma[a[r]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pp[yy]=<span class="number">-1</span>;</span><br><span class="line">pp[zz]=yy-zz;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[a[j]]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">b[a[j]]=<span class="number">1</span>;</span><br><span class="line">ans^=a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">t[l]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;pp[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(pp[i]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> l=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l!=<span class="number">0</span>&amp;&amp;pp[l]+l&lt;pp[i]+i)</span><br><span class="line">&#123;</span><br><span class="line">l--;</span><br><span class="line">&#125;</span><br><span class="line">e[l].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">ff</span>(<span class="number">0</span>)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codeforces.com/contest/811/problem/D">D. Vladik and Favorite Game</a> 这是一道交互题。 交互题其实就是你输出一些东西，然后cf的程序会输入回一些东西，然后你通过这些，来搞一下你的下一步策略。 这个题其实很傻，就是先广搜出一条合理的路径，然后因为一定是先沿边走，所以瞎判断一下就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">bool</span> v[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; la[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> xx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> yy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">char</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c[i][j];</span><br><span class="line">d[i][j]=<span class="number">2</span>*n*m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">v[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">d[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a=q.<span class="built_in">front</span>().first;</span><br><span class="line"><span class="keyword">int</span> b=q.<span class="built_in">front</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">v[a][b]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=a+xx[i];</span><br><span class="line"><span class="keyword">int</span> y=b+yy[i];</span><br><span class="line"><span class="keyword">if</span>(x&lt;=<span class="number">0</span>||x&gt;n) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(y&lt;=<span class="number">0</span>||y&gt;m) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(c[x][y]==<span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(d[a][b]+<span class="number">1</span>&lt;d[x][y])</span><br><span class="line">&#123;</span><br><span class="line">d[x][y]=d[a][b]+<span class="number">1</span>;</span><br><span class="line">la[x][y]=<span class="built_in">make_pair</span>(a,b);</span><br><span class="line"><span class="keyword">if</span>(v[x][y]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">v[x][y]=<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">if</span>(c[i][j]==<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">a=i;</span><br><span class="line">b=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(a!=<span class="number">1</span>||b!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">x=la[a][b].first;</span><br><span class="line">y=la[a][b].second;</span><br><span class="line"><span class="keyword">if</span>(x&lt;a) ans.<span class="built_in">push_back</span>(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(x&gt;a) ans.<span class="built_in">push_back</span>(<span class="string">&#x27;U&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(y&lt;b) ans.<span class="built_in">push_back</span>(<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(y&gt;b) ans.<span class="built_in">push_back</span>(<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">a=x;</span><br><span class="line">b=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bj1=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> bj2=<span class="number">-1</span>;</span><br><span class="line">a=<span class="number">1</span>; b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=ans.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(bj1==<span class="number">-1</span>&amp;&amp;c[a+<span class="number">1</span>][b]!=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pa=a;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;D&#x27;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(a!=pa)</span><br><span class="line">&#123;</span><br><span class="line">bj1=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;U&#x27;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> bj1=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bj2==<span class="number">-1</span>&amp;&amp;c[a][b+<span class="number">1</span>]!=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pb=b;;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;R&#x27;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(b!=pb)</span><br><span class="line">&#123;</span><br><span class="line">bj2=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;L&#x27;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> bj2=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans[i]==<span class="string">&#x27;U&#x27;</span>&amp;&amp;bj1==<span class="number">1</span>) ans[i]=<span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ans[i]==<span class="string">&#x27;D&#x27;</span>&amp;&amp;bj1==<span class="number">1</span>) ans[i]=<span class="string">&#x27;U&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ans[i]==<span class="string">&#x27;L&#x27;</span>&amp;&amp;bj2==<span class="number">1</span>) ans[i]=<span class="string">&#x27;R&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ans[i]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;bj2==<span class="number">1</span>) ans[i]=<span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codeforces.com/contest/811/problem/E">E. Vladik and Entertaining Flags</a> 不错的一道题。 用线段树维护一下左边界和右边界总共2*n个点的并查集，然后做一下并查集的合并。 说起来蛮简单的，但是合并的细节有点多，写起来也有点烦。（可能我的写法比较糟糕）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">15</span>][<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">seg e[<span class="number">400040</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> (&amp;f)[<span class="number">22</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) f[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span> (&amp;f)[<span class="number">22</span>],<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==f[x]) <span class="keyword">return</span> x;</span><br><span class="line">f[x]=<span class="built_in">ff</span>(f,f[x]);</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> (&amp;f)[<span class="number">22</span>],<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="built_in">ff</span>(f,x)]=<span class="built_in">ff</span>(f,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">42</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">44</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ff1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">t[x]=<span class="built_in">ff1</span>(t[x]);</span><br><span class="line"><span class="keyword">return</span> t[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergedsu</span><span class="params">(seg &amp;a,seg &amp;b,seg &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>(a.u);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>*n;i++) t[i]=i;</span><br><span class="line">a.num=b.num+e.num;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][b.r]==c[i][e.l]&amp;&amp;(<span class="built_in">ff1</span>(<span class="built_in">ff</span>(b.u,i+n))!=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(e.u,i)+<span class="number">2</span>*n)))</span><br><span class="line">&#123;</span><br><span class="line">t[<span class="built_in">ff1</span>(<span class="built_in">ff</span>(b.u,i+n))]=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(e.u,i)+<span class="number">2</span>*n);</span><br><span class="line">a.num--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.l=b.l; a.r=e.r;</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff</span>(b.u,i);</span><br><span class="line"><span class="keyword">if</span>(p[tt]==<span class="number">-1</span>) p[tt]=i;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">merge</span>(a.u,p[tt],i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff</span>(e.u,i+n);</span><br><span class="line"><span class="keyword">if</span>(p[tt]==<span class="number">-1</span>) p[tt]=i+n;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">merge</span>(a.u,p[tt],i+n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(e.u,i+n)+<span class="number">2</span>*n);</span><br><span class="line">w[tt]=i+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(b.u,i));</span><br><span class="line"><span class="keyword">if</span>(w[tt]!=<span class="number">-1</span>) <span class="built_in">merge</span>(a.u,i,w[tt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(b.u,i));</span><br><span class="line">w[tt]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(e.u,i+n)+<span class="number">2</span>*n);</span><br><span class="line"><span class="keyword">if</span>(w[tt]!=<span class="number">-1</span>) <span class="built_in">merge</span>(a.u,i+n,w[tt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(b.u,i));</span><br><span class="line">w[tt]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(b.u,i));</span><br><span class="line"><span class="keyword">if</span>(w[tt]!=<span class="number">-1</span>) <span class="built_in">merge</span>(a.u,i,w[tt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(e.u,i+n)+<span class="number">2</span>*n);</span><br><span class="line">w[tt]=i+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="built_in">ff1</span>(<span class="built_in">ff</span>(e.u,i+n)+<span class="number">2</span>*n);</span><br><span class="line"><span class="keyword">if</span>(w[tt]!=<span class="number">-1</span>) <span class="built_in">merge</span>(a.u,i+n,w[tt]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">init</span>(e[x].u);</span><br><span class="line">e[x].l=l; e[x].r=r;</span><br><span class="line">e[x].num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][l]==c[i<span class="number">-1</span>][l]) <span class="built_in">merge</span>(e[x].u,i,i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span> e[x].num++;</span><br><span class="line"><span class="built_in">merge</span>(e[x].u,i,i+n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(x*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(x*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">mergedsu</span>(e[x],e[x*<span class="number">2</span>],e[x*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">seg ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> z,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(z&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(z==l) ans=e[x];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">seg u;</span><br><span class="line"><span class="built_in">mergedsu</span>(u,ans,e[x]);</span><br><span class="line">ans=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(z&lt;=mid) <span class="built_in">query</span>(x*<span class="number">2</span>,l,mid,z,y);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">query</span>(x*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,z,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,m,l,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/811/problem/A&quot;&gt;A. Vladik and Courtesy&lt;/a&gt; 二分查找一下次数就行&lt;/p&gt;</summary>
    
    
    
    <category term="acm" scheme="https://reku1997.gitee.io/categories/acm/"/>
    
    
    <category term="并查集" scheme="https://reku1997.gitee.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="codeforces" scheme="https://reku1997.gitee.io/tags/codeforces/"/>
    
    <category term="树DP" scheme="https://reku1997.gitee.io/tags/%E6%A0%91DP/"/>
    
    <category term="二分查找" scheme="https://reku1997.gitee.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="交互题" scheme="https://reku1997.gitee.io/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Playrix Codescapes Cup (Codeforces Round #413, rated, Div. 1 + Div. 2)</title>
    <link href="https://reku1997.gitee.io/2017/05/16/playrix-codescapes-cup-codeforces-round-413-rated-div-1-div-2/"/>
    <id>https://reku1997.gitee.io/2017/05/16/playrix-codescapes-cup-codeforces-round-413-rated-div-1-div-2/</id>
    <published>2017-05-16T09:11:12.000Z</published>
    <updated>2021-12-16T11:32:41.804Z</updated>
    
    <content type="html"><![CDATA[<p>A,B略 <span id="more"></span></p><p><a href="http://codeforces.com/contest/799/problem/C">C. Fountains</a> 一开始看错了题，还以为是什么很牛逼的背包题。 认真读了读题目，发现只需要两个喷泉，所以要么两个C、两个D、一个C一个D，用树状数组乱搞搞就行，很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BITree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> SIZE = <span class="number">100010</span>, BIAS = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> u[SIZE];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(u,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(x+=BIAS;x&lt;SIZE;x+=x&amp;-x) u[x]=<span class="built_in">max</span>(v,u[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getmax</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(x+=BIAS;x;x-=x&amp;-x) s=<span class="built_in">max</span>(s,u[x]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; cc,dd;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cc.<span class="built_in">clear</span>();</span><br><span class="line">dd.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mac=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mad=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,c,d;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;c&gt;&gt;d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;ch;</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y&lt;=c)&#123; mac=<span class="built_in">max</span>(mac,x);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p=cc.<span class="built_in">getmax</span>(c-y);</span><br><span class="line"><span class="keyword">if</span>(p&amp;&amp;x) ans=<span class="built_in">max</span>(ans,p+x);</span><br><span class="line">cc.<span class="built_in">modify</span>(y,x);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y&lt;=d) &#123;mad=<span class="built_in">max</span>(mad,x);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p=dd.<span class="built_in">getmax</span>(d-y);</span><br><span class="line"><span class="keyword">if</span>(p&amp;&amp;x) ans=<span class="built_in">max</span>(ans,p+x);</span><br><span class="line">dd.<span class="built_in">modify</span>(y,x);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mac&amp;&amp;mad) ans=<span class="built_in">max</span>(ans,mac+mad);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codeforces.com/contest/799/problem/D">D. Field expansion</a> 题目可以转化为，给一列数字，找不相交两组数字相乘的结果分别大于A和B，使得用到的数字最少。 很容易发现，能用大的数字一定用大的。 因为A和B都不超过<span class="math inline">\(100000\)</span>，所以用不超过<span class="math inline">\(34\)</span>个数字一定可以找到一组合法解，那么显然就用最大的<span class="math inline">\(34\)</span>个数字。 然后判断有没有合法解，就拆成两半，然后把所有解生成出来，一半枚举，另一半二分就可以了，蛮常见的处理方式。 要注意这个长方形是可以旋转的...因为没发现可以旋转，错了好多次QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,h,w,n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> e[<span class="number">100010</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> y;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pan</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[<span class="number">2</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ma=<span class="number">1ll</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> u=(<span class="number">2ll</span>&lt;&lt;<span class="number">40</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t/<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">num1++;</span><br><span class="line">p[<span class="number">0</span>][num1]=e[i];</span><br><span class="line"><span class="keyword">if</span>(ma&lt;u) ma*=e[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t-num1;i++)</span><br><span class="line">&#123;</span><br><span class="line">num2++;</span><br><span class="line">p[<span class="number">1</span>][num2]=e[i+num1];</span><br><span class="line"><span class="keyword">if</span>(ma&lt;u) ma*=e[i+num1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ma&lt;x*y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; z1;</span><br><span class="line">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; z2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> g=z1.<span class="built_in">size</span>();</span><br><span class="line">z1.<span class="built_in">pb</span>(p[<span class="number">0</span>][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(z1[j]*p[<span class="number">0</span>][i]&lt;=<span class="number">100000</span>) z1.<span class="built_in">pb</span>(z1[j]*p[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num2;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> g=z2.<span class="built_in">size</span>();</span><br><span class="line">z2.<span class="built_in">pb</span>(p[<span class="number">1</span>][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(z2[j]*p[<span class="number">1</span>][i]&lt;=<span class="number">100000</span>) z2.<span class="built_in">pb</span>(z2[j]*p[<span class="number">1</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">z1.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">z2.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">sort</span>(z1.<span class="built_in">begin</span>(),z1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(z2.<span class="built_in">begin</span>(),z2.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pma=<span class="number">222147483600ll</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;z1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r=z2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(z1[i]*z2[mid]&gt;=x) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z1[i]*z2[l]&gt;=x) pma=<span class="built_in">min</span>(pma,z1[i]*z2[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((ma/pma)&gt;=y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=(a/h)+!!(a%h);</span><br><span class="line">y=(b/w)+!!(b%w);</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(e+<span class="number">1</span>,e+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> r=<span class="built_in">min</span>(<span class="number">34ll</span>,n);</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pan</span>(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pan</span>(l)!=<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ans==<span class="number">-1</span>) ans=l;</span><br><span class="line"><span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;h,&amp;w,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;e[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">suan</span>();</span><br><span class="line"><span class="built_in">swap</span>(h,w);</span><br><span class="line"><span class="built_in">suan</span>();</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codeforces.com/contest/799/problem/E">E. Aquarium decoration</a> 把所有的物品分为四份：A和B都喜欢的，A喜欢的，B喜欢的，A和B都不喜欢的。 然后枚举第一部分找多少个，用两个树状数组加速剩下三部分的计算就好了。我的做法是一个树状数组处理前缀个数，然后另一个处理前缀和，到时候二分就可以了。 写错了好多次...码力好差...</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c[<span class="number">200010</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> a[<span class="number">200010</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">200010</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> qhb[<span class="number">200010</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> qhb1[<span class="number">200010</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> qhb2[<span class="number">200010</span>]=&#123;&#125;;</span><br><span class="line">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; bb;</span><br><span class="line">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; b1;</span><br><span class="line">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; b2;</span><br><span class="line">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; b3;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125; e[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pp x,pp y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.s&lt;y.s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BITree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">400010</span>, BIAS = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> u[SIZE];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(u,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(x+=BIAS;x&lt;SIZE;x+=x&amp;-x) u[x]+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(x+=BIAS;x;x-=x&amp;-x) s+=u[x];</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bh,qh;</span><br><span class="line"><span class="keyword">int</span> ne;</span><br><span class="line"><span class="keyword">int</span> na[<span class="number">200010</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> nb[<span class="number">200010</span>]=&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> o;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;o);</span><br><span class="line">a[o]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> o;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;o);</span><br><span class="line">b[o]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&amp;&amp;b[i]) bb.<span class="built_in">pb</span>(c[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]) b1.<span class="built_in">pb</span>(c[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b[i]) b2.<span class="built_in">pb</span>(c[i]);</span><br><span class="line"><span class="keyword">else</span> b3.<span class="built_in">pb</span>(c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(bb.<span class="built_in">begin</span>(),bb.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(b1.<span class="built_in">begin</span>(),b1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(b2.<span class="built_in">begin</span>(),b2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(b3.<span class="built_in">begin</span>(),b3.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bb.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) qhb[i]=bb[i];</span><br><span class="line"><span class="keyword">else</span> qhb[i]=qhb[i<span class="number">-1</span>]+bb[i];</span><br><span class="line">&#125;</span><br><span class="line">ne=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) qhb1[i]=b1[i];</span><br><span class="line"><span class="keyword">else</span> qhb1[i]=qhb1[i<span class="number">-1</span>]+b1[i];</span><br><span class="line">ne++;</span><br><span class="line">e[ne].s=b1[i];</span><br><span class="line">e[ne].a=i;</span><br><span class="line">e[ne].b=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b2.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) qhb2[i]=b2[i];</span><br><span class="line"><span class="keyword">else</span> qhb2[i]=qhb2[i<span class="number">-1</span>]+b2[i];</span><br><span class="line">ne++;</span><br><span class="line">e[ne].s=b2[i];</span><br><span class="line">e[ne].a=<span class="number">-1</span>;</span><br><span class="line">e[ne].b=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b3.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">ne++;</span><br><span class="line">e[ne].s=b3[i];</span><br><span class="line">e[ne].a=<span class="number">-1</span>;</span><br><span class="line">e[ne].b=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(e+<span class="number">1</span>,e+ne+<span class="number">1</span>,cmp);</span><br><span class="line">bh.<span class="built_in">clear</span>(); qh.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ne;i++)</span><br><span class="line">&#123;</span><br><span class="line">bh.<span class="built_in">modify</span>(i,<span class="number">1</span>);</span><br><span class="line">qh.<span class="built_in">modify</span>(i,e[i].s);</span><br><span class="line"><span class="keyword">if</span>(e[i].a!=<span class="number">-1</span>) na[e[i].a]=i;</span><br><span class="line"><span class="keyword">if</span>(e[i].b!=<span class="number">-1</span>) nb[e[i].b]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">bool</span> bj=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=bb.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((i+<span class="number">1</span>)&gt;m) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((i+<span class="number">1</span>)&gt;=k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((m-i<span class="number">-1</span>)&gt;ne) <span class="keyword">break</span>;</span><br><span class="line">mans+=qhb[i];</span><br><span class="line">mans+=qh.<span class="built_in">getsum</span>(m-i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(ans==<span class="number">-1</span>) ans=mans;</span><br><span class="line"><span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,mans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> w=k-i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> u=m-i<span class="number">-1</span><span class="number">-2</span>*w;</span><br><span class="line"><span class="keyword">if</span>(u&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(w&gt;(<span class="keyword">int</span>)b1.<span class="built_in">size</span>()||w&gt;(<span class="keyword">int</span>)b2.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(i==bb.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w<span class="number">-1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">bh.<span class="built_in">modify</span>(na[j],<span class="number">-1</span>);</span><br><span class="line">bh.<span class="built_in">modify</span>(nb[j],<span class="number">-1</span>);</span><br><span class="line">qh.<span class="built_in">modify</span>(na[j],-b1[j]);</span><br><span class="line">qh.<span class="built_in">modify</span>(nb[j],-b2[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w--;</span><br><span class="line">mans+=qhb[i];</span><br><span class="line">mans+=qhb1[w];</span><br><span class="line">mans+=qhb2[w];</span><br><span class="line">bh.<span class="built_in">modify</span>(na[w],<span class="number">-1</span>);</span><br><span class="line">bh.<span class="built_in">modify</span>(nb[w],<span class="number">-1</span>);</span><br><span class="line">qh.<span class="built_in">modify</span>(na[w],-b1[w]);</span><br><span class="line">qh.<span class="built_in">modify</span>(nb[w],-b2[w]);</span><br><span class="line"><span class="keyword">if</span>(u!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> r=ne;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(bh.<span class="built_in">getsum</span>(mid)&gt;=u) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bh.<span class="built_in">getsum</span>(l)==u) mans+=qh.<span class="built_in">getsum</span>(l);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==<span class="number">-1</span>) ans=mans;</span><br><span class="line"><span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,mans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) bj=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bb.<span class="built_in">size</span>()==<span class="number">0</span>) bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(bj&amp;&amp;<span class="number">2</span>*k&lt;=m&amp;&amp;k&lt;=b1.<span class="built_in">size</span>()&amp;&amp;k&lt;=b2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> w=k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mans=<span class="number">0</span>;</span><br><span class="line">w--;</span><br><span class="line">mans+=qhb1[w];</span><br><span class="line">mans+=qhb2[w];</span><br><span class="line">bh.<span class="built_in">modify</span>(na[w],<span class="number">-1</span>);</span><br><span class="line">bh.<span class="built_in">modify</span>(nb[w],<span class="number">-1</span>);</span><br><span class="line">qh.<span class="built_in">modify</span>(na[w],-b1[w]);</span><br><span class="line">qh.<span class="built_in">modify</span>(nb[w],-b2[w]);</span><br><span class="line"><span class="keyword">int</span> u=m<span class="number">-2</span>*k;</span><br><span class="line"><span class="keyword">if</span>(u!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> r=ne;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(bh.<span class="built_in">getsum</span>(mid)&gt;=u) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bh.<span class="built_in">getsum</span>(l)==u) mans+=qh.<span class="built_in">getsum</span>(l);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">mans=ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==<span class="number">-1</span>) ans=mans;</span><br><span class="line"><span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,mans);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;A,B略&lt;/p&gt;</summary>
    
    
    
    <category term="acm" scheme="https://reku1997.gitee.io/categories/acm/"/>
    
    
    <category term="codeforces" scheme="https://reku1997.gitee.io/tags/codeforces/"/>
    
    <category term="树状数组" scheme="https://reku1997.gitee.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    <category term="折半搜索" scheme="https://reku1997.gitee.io/tags/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
</feed>
